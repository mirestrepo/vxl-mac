1. Get and install CMake

CMake website is at http://public.kitware.com/CMake/. I recommend
getting the sources via CVS: (see the section on "downloading" on the
webpage)
   cvs -d :pserver:anonymous@public.kitware.com:/CMake/cvsroot login
(respond with password cmake)
   cvs -d :pserver:anonymous@public.kitware.com:/CMake/cvsroot co CMake

Under Visual C++, load CMakeSetup.dsw and compile the projects in
there. This will generate a program "CMakeSetup", which is what you
will run whenever I talk about running CMake.

Under Unix, do a standard
  ./configure
  make
I suggest that you _not_ run "make install", because you will (should)
be updating CMake relatively often. In the following, I will use
$CMAKE to refer to the newly generated
binary. (CMAKE_DIR/Source/cmake, if you don't perform the install
step.)

Better yet, especially if you are going to build for more than one platform:
  cd CMAKE_DIR
  mkdir CMake-build-for-`uname`
  (or something like that: a platform-unique name)
  cd CMake-build-for-`uname`
  ../configure
  make
Now $CMAKE is CMAKE_DIR/CMake-build-for-`uname`/Source/cmake

2. Compile with CMake

Use $VXLSRC to refer to the vxl source tree. (This is $IUEROOT in the
old make system.) Create a different directory $VXLBIN, one per platform,
and run CMake from within that directory.

For Visual C++ users, run CMakeSetup and enter $VXLSRC and $VXLBIN
appropriately. This will generate $VXLBIN/allvxl.dsw, and everything
can be done from there.

For Unix users:
  cd $VXLBIN
  $CMAKE $VXLSRC

This will generate the makefiles within $VXLBIN. You can now do a
"make" to build everything, or else go to a project of interest and
run "make"--the dependent libraries should be automatically
built. Although the generated makefiles will work with most make
programs, it works best with GNU make.

If you are using Solaris you should build with this option
  $CMAKE -DSOLARIS:STRING=1 $VXLSRC
CMake does not automatically detect that that you are using Solaris.
Some CMakeListsLink.txt files (vxl/vil/CMakeListsLink.txt for one) in
VXL use the SOLARIS variable to control the use of the socket library.

If you are using Cygwin and have installed the Cygwin OpenGL package,
you probably want to build with this option
  $CMAKE -DX11_INCLUDE_PATH:PATH=IGNORE $VXLSRC
This prevents CMake from using the X11 headers and libraries.  The
OpenGL package puts its header files in /usr/include/GL/ and the
XFree86 package puts some header files in /usr/X11R6/include/GL/.  If
you configure to use header files from /usr/X11R6/include then the
XFree86 GL/*.h files will be used instead of the OpenGL package GL/*.h
files.  These two sets of header files are not compatible.  Using the
wrong ones will lead to linking problems involving mismatched suffixes
like @4, @8, and @12.

3. The CMakeCache.txt

The build system is configured by setting "cache" values, which are
specified in $VXLBIN/CMakeCache.txt. These values can be edited using
a plain old editor or using the CMake GUI. (There is apparently a
CMake GUI under Unix for those with FLTK.)

When running $CMAKE for the first time, sensible default values are
written into CMakeCache.txt, and you will not need changing any of
these if everything compiles and runs fine.  However, running $CMAKE
from a directory that already contains a CMakeCache.txt will use the
values in there, so it is worth having a look at the settings in that
file, e.g. for the location of JPEG, TIFF, etc.

4. Doing an in-place build

If you don't make a new directory for $VXLBIN, but instead use
$VXLBIN=$VXLSRC, you will get an in-place build. The major
disadvantage is that you cannot have different build options, since
the build options are given in the CMakeCache.txt and there is only
one of those per build tree.

(If you use emacs and like to run compile from within emacs, I have a
small emacs library vxl-compile.el (mostly copied from compile.el)
that will handle out-of-place builds.)
