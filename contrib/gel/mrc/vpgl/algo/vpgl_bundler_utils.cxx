#include <vpgl/algo/vpgl_bundler_utils.h>

#include <vcl_cmath.h>
#include <vcl_cstdlib.h>

#include <vgl/vgl_vector_3d.h>

#include <vnl/vnl_matrix_fixed.h>
#include <vnl/vnl_vector_fixed.h>
#include <vnl/vnl_matrix.h>
#include <vnl/vnl_vector.h>
#include <vnl/vnl_double_3x3.h>
#include <vnl/vnl_inverse.h>
#include <vnl/algo/vnl_svd.h>


// Generally useful function used for RANSAC.
// Randomly chooses n distinct indices into the set
void vpgl_bundler_utils_get_distinct_indices(
    int n, int *idxs, int number_entries)
{
    for (int i = 0; i < n; i++) {
        bool found;
        int idx;

        do {
            found = true;
            idx = vcl_rand() % number_entries;

            for (int j = 0; j < i; j++) {
                if (idxs[j] == idx) {
                    found = false;
                    break;
                }
            }
        } while (!found);

        idxs[i] = idx;
    }
}


/*-----------------------------------------------------------------------*/
// Another generally useful function. Takes in a list of points and
// cameras, and finds the least-squared solution to the intersection
// of the rays generated by the points.
double vpgl_bundler_utils_triangulate_points(
    vpgl_bundler_inters_3d_point &point,
    const vcl_vector<vpgl_bundler_inters_camera> &cameras)
{
    const int num_vars = 3;
    const int num_eqs = 2 * point.origins.size();

    // Set up the least-squares solution.
    vnl_matrix<double> A(num_eqs, num_vars, 0.0);
    vnl_vector<double> b(num_eqs, 0.0);

    for (int i = 0; i < point.origins.size(); i++) {
        const vgl_vector_3d<double> &trans =
            cameras[i].camera.get_translation();

        const vnl_matrix_fixed<double, 3, 3> rot =
            cameras[i].camera.get_rotation().as_matrix();

        // Set the row fo x for this point
        A.put(2 * i, 0, 
            rot.get(0, 0) - point.origins[i]->x() * rot.get(2, 0) );
        A.put(2 * i, 1, 
            rot.get(0, 1) - point.origins[i]->x() * rot.get(2, 1) );
        A.put(2 * i, 2, 
            rot.get(0, 2) - point.origins[i]->x() * rot.get(2, 2) );

        // Set the row for y for this point
        A.put(2*i+1, 0,  
            rot.get(1, 0) - point.origins[i]->y() * rot.get(2, 0) );
        A.put(2*i+1, 1, 
            rot.get(1, 1) - point.origins[i]->y() * rot.get(2, 1) );
        A.put(2*i+1, 2,  
            rot.get(1, 2) - point.origins[i]->y() * rot.get(2, 2) );

        // Set the RHS row.
        b[2*i + 0] = trans.z() * point.origins[i]->x() - trans.x();
        b[2*i + 1] = trans.z() * point.origins[i]->y() - trans.y();
    }


    // Find the least squares result
    vnl_svd<double> svd(A);
    vnl_vector_fixed<double, 3> x = svd.solve(b);

    point.point_3d.set(x.begin());

    // Find the error
    double error = 0.0;
    for (int i = 0; i < point.origins.size(); i++) {
        // Compute projection error
        vnl_vector_fixed<double, 3> pp =
            cameras[i].camera.get_rotation().as_matrix() * x;

        pp[0] += cameras[i].camera.get_translation().x();
        pp[1] += cameras[i].camera.get_translation().y();
        pp[2] += cameras[i].camera.get_translation().z();

        double dx = pp[0] / pp[2] - point.origins[i]->x();
        double dy = pp[1] / pp[2] - point.origins[i]->y();
        error += dx * dx + dy * dy;
    }

    return vcl_sqrt(error / point.origins.size());
}

/*-----------------------------------------------------------------------*/
// Takes in four matched points, and fills a 3x3 homography matrix
// Uses the direct linear transform method
void vpgl_bundler_utils_get_homography(
    const vcl_vector<vgl_point_2d<double> > &rhs,
    const vcl_vector<vgl_point_2d<double> > &lhs,
    vnl_double_3x3 &homography)
{
    assert(rhs.size() == 4);
    assert(lhs.size() == 4);

    vnl_matrix_fixed<double, 8, 8> A(0.0); // Left-hand matrix
    vnl_vector_fixed<double, 8> b(0.0); // Right-hand vector


    // Fill the right and left hand side. We are solving the equation Ax=b,
    // where x is the vectorized version of the homography,
    // b = [x_r1 y_r1 x_r2 y_r2 x_r3 y_r3 x_r4 y_r4]^T, and
    //
    // A = [x_l1 y_l1 1 0 0 0 -(x_l1*x_r1) -(y_l1*x_r1)]
    //     [0 0 0 x_l1 y_l1 1 -(x_l1*yr_1) -(y_l1*y_r1)]
    //     ...
    // For more information, look up the direct linear transform for
    // computing homographies
    for (int i = 0; i < 4; i++) {
        // Set the first row for this point
        A.put(2*i, 0, lhs[i].x());
        A.put(2*i, 1, lhs[i].y());
        A.put(2*i, 2, 1.0);

        A.put(2*i, 6, -lhs[i].x() * rhs[i].x());
        A.put(2*i, 7, -lhs[i].y() * rhs[i].x());

        // Set the second row for this point
        A.put(2*i+1, 3, lhs[i].x());
        A.put(2*i+1, 4, lhs[i].y());
        A.put(2*i+1, 5, 1.0);

        A.put(2*i+1, 6, -lhs[i].x() * rhs[i].y());
        A.put(2*i+1, 7, -lhs[i].y() * rhs[i].y());


        // Set the two rows in the B vector
        b.put(2*i, rhs[i].x());
        b.put(2*i+1, rhs[i].y());
    }

    // Solve the least squares problem
    vnl_svd<double> svd(A);
    vnl_vector<double> linear_homography = svd.solve(b);

    // Now transform the linearized homography into the
    // square matrix version
    for (int i = 0; i < 8; i++) {
        homography.put( i / 3, i % 3, linear_homography.get(i));
    }

    homography.put(2, 2, 1);
}


// Estimates a homography and returns the percentage of inliers
double vpgl_bundler_utils_get_homography_inlier_percentage(
    const vpgl_bundler_inters_match_set &match, 
    double threshold_squared, int num_rounds)
{
    int inlier_count = 0;

    // RANSAC!
    for (int round = 0; round < num_rounds; round++){
        int match_idxs[4];
        vpgl_bundler_utils_get_distinct_indices(
            4, match_idxs, match.num_features());

        // Fill these vectors with the points stored at the indices`
        vcl_vector<vgl_point_2d<double> > rhs;
        vcl_vector<vgl_point_2d<double> > lhs;

        for (int i = 0; i < 4; i++) {
            lhs.push_back(match.side1[match_idxs[i]]->point);
            rhs.push_back(match.side2[match_idxs[i]]->point);
        }

        // Get the homography for the points
        vnl_double_3x3 homography;
        vpgl_bundler_utils_get_homography(rhs, lhs, homography);


        // Count the number of inliers
        vnl_vector_fixed<double, 3> lhs_pt, rhs_pt;
        lhs_pt[2] = 1.0;

        int current_num_inliers = 0;

        vcl_vector<vpgl_bundler_inters_feature_sptr>::const_iterator s1, s2;
        for (s1 = match.side1.begin(), s2 = match.side2.begin();
             s1 != match.side1.end(); s1++, s2++)
        {
            lhs_pt[0] = (*s1)->point.x();
            lhs_pt[1] = (*s1)->point.y();

            rhs_pt = homography * lhs_pt;

            double dx = (rhs_pt[0] / rhs_pt[2]) - (*s2)->point.x();
            double dy = (rhs_pt[1] / rhs_pt[2]) - (*s2)->point.y();

            if (dx*dx + dy*dy <= threshold_squared) {
                current_num_inliers++;
            }
        }

        if (inlier_count < current_num_inliers) {
            inlier_count = current_num_inliers;
        }
    }

    return ((double) inlier_count) / match.side1.size();
}

