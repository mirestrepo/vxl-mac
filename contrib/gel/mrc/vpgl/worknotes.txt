Issues for 3/8/06 build:
Thomas Pollard
tpollard@dam.brown.edu


Major Issues:

Some classes still need streaming operators.

I haven't been paying close enough attention to numerical errors in == statements
and I'll need to go back at some point and sprinkle error tolerances all over.

There are many cases in which the user is able to supply bad data (ex. a camera
matrix with rank < 3 ) and I've been largely printing warnings instead of using
assertions, but I'm not sure which is more appropriate.

There's one warning when compiling vpgl and I'm not sure what to do about it, but
I'm sure someone else would know...



Minor Issues:

Due to the automatic SVD computation and recomputation, many of the 
external functions for vpgl_proj_camera that should take a const 
camera arguement don't because the internal vnl_svd might change upon 
accessing if it hasn't been computed.

subclasses of vpgl_proj_camera can call set_matrix() when they shouldn't
be allowed to.

The template argument needs to have the following defined for it:
 +,-,*,/,<,(T)0,(T)1,abs 

Fmatrix had an option to set the matrix to be rank 2, but in 
vpgl_fundamental_matrix the matrix is forced to be rank2.

In vpgl_fundamental_matrix, the svd is computed at the beginning since it is 
needed in almost all of the operations.

vpgl_proj_camera::is_behind_camera needs some work.  I've implemented the old
vpg_p_camera equivalent, but it requires a cast from the template T into a
double. I'll have to think later about how this would work in general, which
we'll need for complex numbers.  It seems that T will have to be a totally
ordered set if nothing else.

vgl_p_matrix::backproject_pseudoinverse converts to double before finding
the backprojection, but my implementation in vpgl_proj_matrix::backproject
doesn't.  Are there precision advantages to casting?

Gave a new implementation of vgl_p_matrix::get_canonical_h in the external
function get_canonical( vpgl_proj_camera ).  The old implementation required
the first 3x3 block of the camera matrix to be invertible while the new version
doesn't.  Its also worth noting that the canonical H in question is not unique.

Didn't bother with vgl_p_matrix::flip_sign(), seems irrelevant.

Some implemented functions won't work in templated generality and assume
conversions to double.  They are:
  vpgl_proj_camera::is_behind_camera()
  looks_conditioned( vpgl_proj_camera )
  fix_cheirality( vpgl_proj_camera )

Haven't implemented fix_cheirality, not sure how to abstract.



