<HTML>
<HEAD>
<TITLE>VXL: vcl</TITLE>

<META NAME="description" CONTENT="VXL: vcl">
<META NAME="keywords" CONTENT="VXL: vcl">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html @T2H_VERSION@">

</HEAD>

<BODY LANG="" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC16"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book_1.html#SEC1"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book_3.html#SEC18"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book_11.html#SEC56">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>

<HR SIZE=2>
<H1> 2. vcl: C++ compatibility </H1>
<!--docid::SEC16::-->
<P>

<BLOCKQUOTE>
<STRONG>Chapter summary</STRONG>:<BR>
When you want a <CODE>std::string</CODE>, use <CODE>vcl_string</CODE>.
</BLOCKQUOTE>
<P>

The job of vcl is to fix your compiler.  C++ is not just a language; the
standard also includes an extensive library of classes and functions, which
make ISO C++ a powerful and useful tool for building computer programs.
Unfortunately, few C++ compilers available in 2000 have a bug-free
implementation of the standard, so we have to supply our own bug fixes.
</P><P>

To give an example of the type of problems that vcl fixes, here are a few
interpretations from the standard which have been observed in some well
known vendors' libraries.  Many are entirely within the letter of the law,
but remain prone to introduce confusion.
</P><P>

On one compiler, <CODE>&#60;iostream&#62;</CODE> and <CODE>&#60;iostream.h&#62;</CODE> refer to
entirely different stream libraries, which may not be linked together.
Therefore every file in the program must use the same header.  For us, the
<CODE>&#60;iostream&#62;</CODE> version is appropriate, but of course, not all of the
unix compilers support its use.  The solution is for every v<EM>x</EM>l program
to include <CODE>&#60;vcl/vcl_iostream.h&#62;</CODE>.  In this way, we can maintain
consistency between the many compilers, and if we ever do need to use
another stream library, we can make the switch in one place.
Thus rule one is
<BLOCKQUOTE>
Wherever you wish to include standard header <CODE>&#60;foo&#62;</CODE>, you should
include <CODE>&#60;vcl/vcl_foo.h&#62;</CODE> instead.
</BLOCKQUOTE>
<P>

Some compilers place STL classes such as <CODE>vector</CODE> and <CODE>vcl_string</CODE> in
namespace <CODE>std</CODE>, some don't.  Yet others place them there, but do not
implement namespaces properly.  Therefore, it is very difficult to write
portable code because sometimes one must say <CODE>std::vector</CODE>, sometimes
one must use <CODE>vector</CODE>.  Again, we need a way which works on all
systems.  We could try to insert <CODE>using namespace std;</CODE> or <CODE>using
std::vector</CODE> commands throughout the program, but (a) this is not
considered good C++, and (b) it doesn't work anyway.
</P><P>

The low-tech solution is simply to prefix each standard identifier with
<CODE>vcl_</CODE>, so that <CODE>vcl_vector</CODE> works everywhere.  And this is
what v<EM>x</EM>l does, when you include <CODE>&#60;vcl/vcl_vector.h&#62;</CODE>.  Thus, safe
programmers prefix <EM>everything</EM> in the standard library with
<CODE>vcl_</CODE>.
<BLOCKQUOTE>
Wherever you wish to use standard class or function <CODE>foo</CODE>, you should
write <CODE>vcl_foo</CODE> instead.
</BLOCKQUOTE>
This may seem excessive, but one gets used to it very quickly, and it
quickly indicates to novice C++ programmers which functions are from the
standard library.  You might think that the designers of v<EM>x</EM>l would have
been clever enough to avoid the vcl_ prefix by using fancy compiler flags,
and many #defines.  However, that way lies madness--trying to confuse a
C++ compiler always rebounds on one.
<P>

<HR SIZE="6">
<A NAME="SEC17"></A>
<H2> 2.1 Example </H2>
<!--docid::SEC17::-->
This program is exemplary.  It shows how every identifier in the ISO
library has been prefixed by <CODE>vcl_</CODE>.  It may look like extreme
overkill, but it works, and can be made to work on all compilers we've
seen.
<TABLE><tr><td>&nbsp;</td><td class=example><pre>#include &#60;vcl/vcl_string.h&#62;
#include &#60;vcl/vcl_iostream.h&#62;
#include &#60;vcl/vcl_vector.h&#62;
#include &#60;vcl/vcl_algorithm.h&#62;

int main()
{
  vcl_vector&#60;vcl_string&#62; strings;
  strings.push_back("Hello, ");
  strings.push_back("World.");
  vcl_copy(strings.begin(), strings.end(),
           vcl_ostream_iterator&#60;vcl_string&#62;(vcl_cout));
  return 0;
}
</pre></td></tr></table>The alternative is somewhat scary.  It begins
<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>#if defined(_WIN32) || (defined(__SUNPRO_CC) &#38;&#38; (__SUNPRO_CC + 0) &#62;= 0x500)
#include &#60;string&#62;
#else
#include ...
</FONT></pre></td></tr></table><P>

This document has little more to say about the contents of VCL--a book on
C++ should describe it better than we can.  However, it is important to
note that nothing more can go in there.  If it's not in the standard, it's
not in VCL.  Remember, VCL is full, nothing else can go in there.  It
cannot for example be "helpfully" modified, Microsoft-style, to send
standard error to a window (but see  <A HREF="book_3.html#vbl_redirector">vbl_redirector</A>).
</P><P>

<A NAME="vbl"></A>
<HR SIZE="6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[ &lt;&lt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[ &gt;&gt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book_11.html#SEC56">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
</BODY>
</HTML>
