<HTML>
<HEAD>
<TITLE>VXL: vil</TITLE>

<META NAME="description" CONTENT="VXL: vil">
<META NAME="keywords" CONTENT="VXL: vil">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html @T2H_VERSION@">

</HEAD>

<BODY LANG="" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC38"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book_4.html#SEC27"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book_6.html#SEC48"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book_11.html#SEC56">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>

<HR SIZE=2>
<H1> 5. vil: Imaging </H1>
<!--docid::SEC38::-->
<P>

<BLOCKQUOTE>
<STRONG>Chapter summary</STRONG>:<BR>
Load images using <CODE>vil_load</CODE>. Access them
 using a <CODE>vil_memory_image_of&#60;T&#62;</CODE>.
</BLOCKQUOTE>
<P>

The v<EM>x</EM>l image library is an evolutionary rewrite of the TargetJr Image
library.  As with its predecessor, its primary goal is to provide flexible
and powerful access to all 2D images, including those too large to fit in
the address space of a single program or process.  This goal must be
achieved, however, without affecting the speed or complexity of
the much more common case of programs which can read all their images into
main memory and process them in-core.  In fact, both cases need similar
treatment: even in-core images are assumed to be sufficiently large (say a
megabyte) that special care must be taken to avoid unnecessary copying of
their data.  In both cases, the normal requirements of efficiency and
ease-of-use apply.  The system must allow:
<UL>
<LI>Fast access to images on disk, at no more than a 10% speed penalty
for operations on images in memory.
<P>

<LI>Fast loading of subsets of the image data.  To look at a
small portion of a 10000 by 10000 pixel satellite image, one should
not have to load the entire 300 megabytes into memory.
<P>

<LI>Efficient access to the native image layout.  Some systems convert
all images to a consistent internal format when loading, for example, RGB
top-to-bottom.  This is convenient for users, and is what vil's
<CODE>vil_load_rgb</CODE> function does.  However, for some applications, the
disk format is specially designed for efficiency, so it must also be
possible to get raw access to the disk format.
<P>

<LI>Efficient memory management, both automatic and programmer-mediated.
Automatic management is vital during program development, when the code is
changing quickly.  On the other hand, release builds need the kind of
optimizations that only a human can apply.
</UL>
<P>

<HR SIZE="6">
<A NAME="SEC39"></A>
<H2> 5.1 Loading and saving </H2>
<!--docid::SEC39::-->
Let's look at an example of vil in use.  This program makes an image from a
disk file, copies it into memory, and prints the pixel at
100,100.
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>#include &#60;vcl/vcl_iostream.h&#62;
#include &#60;vil/vil_load.h&#62;
#include &#60;vil/vil_memory_image_of.h&#62;

int main()
{
  vil_image img = vil_load("foo.ppm");
  vil_memory_image_of&#60;unsigned char&#62; buf(img);
  vcl_cerr &#60;&#60; "Pixel 100,100 = " &#60;&#60; buf(100,100) &#60;&#60; endl;
}
</pre></td></tr></table></P><P>

Let's go through the program line by line<A NAME="DOCF1" HREF="book_fot.html#FOOT1">(1)</A>, and see in
detail what is happening.  The first interesting line is this call to
<CODE>vil_load</CODE>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>  vil_image img = vil_load("foo.ppm");
</pre></td></tr></table>The load function opens the file given to it, "foo.pgm" here, and examines
its contents to determine what kind of image it is.  Then it makes a
<CODE>vil_image</CODE> object which holds the open file, and remembers details
like the image size.  It doesn't read the image yet, but it remembers
enough to later read any rectangular section of the image.  This object is
returned and assigned to the variable <VAR>img</VAR>. Image objects such as
<VAR>img</VAR> behave like <EM>smart pointers</EM>---they can be copied around
easily and cheaply, because they always point to the same image.
</P><P>

<A NAME="IDX15"></A>
In this case we're not going to bother about handling large images, so the
next line reads the whole lot into a memory buffer:
<TABLE><tr><td>&nbsp;</td><td class=example><pre>  vil_memory_image_of&#60;unsigned char&#62; buf(img);
</pre></td></tr></table>This creates a 2D array of the same size as <VAR>img</VAR>, and reads the image
data from disk into it.  We can now easily access the data using the
overloaded parenthesis operator, and print out the value.
<TABLE><tr><td>&nbsp;</td><td class=example><pre>  cerr &#60;&#60; "Pixel 100,100 = " &#60;&#60; buf(100,100) &#60;&#60; endl;
</pre></td></tr></table>Memory images are derived classes of vil_image, and they too can be passed
around cheaply, always referring to the same block of pixels.  To copy a
memory image, use See  <A HREF="book_5.html#sec:vil_copy">sec:vil_copy</A>.
</P><P>

<HR SIZE="6">
<A NAME="SEC40"></A>
<H3> 5.1.1 Loading and saving: The threshold program </H3>
<!--docid::SEC40::-->
Anyway, the usual next step in demonstrating an image handling library is
to show thresholding, so let's have a look.  This program loads an image
into memory, and creates a new image where all pixels greater than a
threshold value are set to 255.
<TABLE><tr><td>&nbsp;</td><td class=example><pre>#include &#60;vil/vil_load.h&#62;
#include &#60;vil/vil_memory_image_of.h&#62;

int main()
{
  vil_image img = vil_load("foo.ppm");

  vil_memory_image_of&#60;unsigned char&#62; buf(img);

  for(int y = 0; y &#60; buf.height(); ++y)
    for(int x = 0; x &#60; buf.width(); ++x)
      if (buf(x,y) &#60; 200)
	buf(x,y) = 0;

  vil_save(buf, "foothresh.ppm");
}
</pre></td></tr></table>The call to <CODE>vil_save</CODE> sends the modified image in <VAR>buf</VAR> to disk.
The choice of file format is determined automatically from the extension of
the filename.  In this case, the extension is "pgm", the Portable Gray Map
format.  If one wants more control, a string can be appended to specify the
format, e.g.
<A NAME="IDX16"></A>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>  vil_save(buf, "foothresh.ppm", "jpeg");
</pre></td></tr></table>Of course, it's rarely sensible to have incompatible names and formats, but
the user of your program may have chosen the name, so that you have no
other option.
<P>

<HR SIZE="6">
<A NAME="SEC41"></A>
<H3> 5.1.2 Handling different pixel formats </H3>
<!--docid::SEC41::-->
<P>

The programs given so far are a bit limited in that they can only operate
on greyscale images.  If you give a colour image to the <EM>threshold</EM>
program, it will terminate suddenly when it tries to copy the 24-bit RGB
image into an 8bpp (bits per pixel) buffer.  One way to handle multiple
formats is to choose the most general format one is likely to encounter and
convert all images to it.  In the examples above, a
pretty safe choice is to convert all images to 24-bit RGB at load time.
The colour threshold program looks like this:
<TABLE><tr><td>&nbsp;</td><td class=example><pre>#include &#60;vil/vil_load.h&#62;
#include &#60;vil/vil_memory_image_of.h&#62;
#include &#60;vil/vil_rgb_byte.h&#62;

int main()
{
  vil_image img = vil_load_rgb("foo.ppm");

  vil_memory_image_of&#60;vil_rgb_byte&#62; buf(img);

  for(int y = 0; y &#60; buf.height(); ++y)
    for(int x = 0; x &#60; buf.width(); ++x)
      if (buf(x,y).R &#60; 200 &#38;&#38; buf(x,y).G &#60; 200 &#38;&#38; buf(x,y).B &#60; 200)
        buf(x,y) = vil_rgb_byte(0,0,0);

  vil_save(buf, "foothresh.ppm");
}
</pre></td></tr></table><A NAME="IDX17"></A>
This code introduces <CODE>vil_load_rgb</CODE>, which forces any format it is
given into RGB.  It also uses the <CODE>vil_rgb_byte</CODE> class, which is a
simple way to handle RGB triples.
</P><P>

<HR SIZE="6">
<A NAME="SEC42"></A>
<H2> 5.2 Creating images from scratch </H2>
<!--docid::SEC42::-->
Sometimes one would like to write a program which creates images, rather
than modifying an existing one.  Of course, the programs above do this,
because a <CODE>vil_memory_image_of&#60;T&#62;</CODE> is indeed a <CODE>vil_image</CODE>.
An example where one creates a completely new image is in generating an
image of constant value, perhaps to use as a background, or test image.  This
program creates a 256x256 image filled with the value 128.
<TABLE><tr><td>&nbsp;</td><td class=example><pre>#include &#60;vil/vil_load.h&#62;
#include &#60;vil/vil_memory_image_of.h&#62;

int main()
{
  vil_memory_image_of&#60;unsigned char&#62; buf(256, 256);

  buf.fill(128);

  vil_save(buf, "foothresh.ppm");
}
</pre></td></tr></table><P>

<HR SIZE="6">
<A NAME="SEC43"></A>
<H2> 5.3 Copying an image </H2>
<!--docid::SEC43::-->
<A NAME="sec:vil_copy"></A>
<A NAME="IDX18"></A>
You should know by know that copying <CODE>vil_image</CODE> objects does not
duplicate the data they point to.  This allows images to be passed into and
out of functions efficiently.  It also means that modifying the data in one
vil_image might change that in another.  Take this example
<TABLE><tr><td>&nbsp;</td><td class=example><pre>...
vil_memory_image_of&#60;float&#62; a = vil_load("x");
vil_memory_image_of&#60;float&#62; b = a;
b(100,100) = 12;
...
</pre></td></tr></table>After the assignment in line 3, both <VAR>a(100,100)</VAR> and <VAR>b(100,100)</VAR>
are set to the value 12.  On the other hand, if we had used
<CODE>vil_copy</CODE>, thus:
<TABLE><tr><td>&nbsp;</td><td class=example><pre>...
vil_memory_image_of&#60;float&#62; a = vil_load("x");
vil_memory_image_of&#60;float&#62; b = vil_copy(a);
b(100,100) = 12;
...
</pre></td></tr></table>then <VAR>a</VAR> is unchanged after the assignment to <VAR>b(100,100)</VAR>.
Note again that the actual copying is done in <CODE>vil_copy</CODE>; when the
return value is assigned to <VAR>b</VAR>, there is an efficient pointer copy.
<P>

<HR SIZE="6">
<A NAME="SEC44"></A>
<H2> 5.4 Dealing with large images </H2>
<!--docid::SEC44::-->
<P>

Most users of v<EM>x</EM>l deal with small images, which it is sensible to copy
into a <CODE>vil_memory_image</CODE> before operating on them.  If you are like
most users, or if this is your first time through the book, you may skip
the rest of this chapter.  If you are like many programmers, however, you
might like to know what vil is like under the hood.
</P><P>

When a very large image does have to be analysed, it is generally faster to
allow the image to remain on disk, and only load sections when needed (for
example, when displayed on the screen).  Because it is computationally
cheap to support this usage, vil does so.  To understand how large images
are handled, we look again at the <CODE>vil_image</CODE> class.
</P><P>

<HR SIZE="6">
<A NAME="SEC45"></A>
<H3> 5.4.1 The image class: <CODE>vil_image</CODE> </H3>
<!--docid::SEC45::-->
<P>

The heart of the imaging library is the class <CODE>vil_image</CODE>, which
contains a handle to an image, which may be in memory, or on disk.  Most
image-handling code in v<EM>x</EM>l operates on blocks of the image, so that
large images can be processed efficiently.  As in TargetJr, the key
operations on a <CODE>vil_image</CODE> are the block read and write operations:
<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>   i.get_section(buffer, rect_x0, rect_y0, rect_width, rect_height);
   i.put_section(buffer, rect_x0, rect_y0, rect_width, rect_height);
</FONT></pre></td></tr></table>The <CODE>get_section</CODE> method copies pixels from the image to the
user-supplied memory in <CODE>buffer</CODE>, which must be pre-initialized to
the appropriate size.
</P><P>

<HR SIZE="6">
<A NAME="SEC46"></A>
<H3> 5.4.2 Example: Printing a pixel from a greylevel image </H3>
<!--docid::SEC46::-->
Without much more explanation, here is the vil code to print the value at
pixel location (100,200).  It assumes blithely that the file "theimage.pgm"
exists, is readable, and contains a grey image whose size is at least 100
by 200 pixels:
<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>main()
{
   vil_image img = vil_load("theimage.pgm");
   vil_byte value; // buffer into which value will be read
   img.get_section(&#38;value, 100, 200, 1, 1);
   cerr &#60;&#60; "val(100,200) = " &#60;&#60; int(value) &#60;&#60; endl;
}
</FONT></pre></td></tr></table><P>

<HR SIZE="6">
<A NAME="SEC47"></A>
<H3> 5.4.3 Image layout </H3>
<!--docid::SEC47::-->
The vil image is a 2D array of pixels.  Pixels come in many guises and
sizes: integers, floating point numbers, tuples of numbers such as RGB.
It is important in VIL to know about layout, meaning the order in which the
numbers are laid out in memory or on the disk.  The obvious order for an
image which corresponds to a video signal is left-to-right, top-to-bottom;
however not all images are video signals, and many alternatives are
common.  Some of these types of alternative are handled explicitly by
vil, most others can be handled easily using vil's extension facilities.
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>

   vil_image      -- contains_a --&#62;    vil_image_impl
    |                                   |
    +vil_memory_image                   +vil_memory_image_impl
    | |                                 |
    | +vil_memory_image_of&#60;T&#62;           +vil_pnm_image_impl
    |                                   |
    +vil_file_image                     ... etc


</pre></td></tr></table><BLOCKQUOTE>
<STRONG>Figure 4:</STRONG>
The parallel <CODE>vil_image</CODE> and <CODE>vil_image_impl</CODE> class hierarchies.
</BLOCKQUOTE>
<P>

@ejectallfigures
</P><P>

<A NAME="vgl"></A>
<HR SIZE="6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[ &lt;&lt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[ &gt;&gt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book_11.html#SEC56">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
</BODY>
</HTML>
