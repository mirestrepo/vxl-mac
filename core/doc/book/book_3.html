<HTML>
<HEAD>
<TITLE>VXL: vbl</TITLE>

<META NAME="description" CONTENT="VXL: vbl">
<META NAME="keywords" CONTENT="VXL: vbl">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html @T2H_VERSION@">

</HEAD>

<BODY LANG="" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC18"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book_1.html#SEC1"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book_4.html#SEC27"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book_11.html#SEC56">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>

<HR SIZE=2>
<H1> 3. vbl: Basics </H1>
<!--docid::SEC18::-->
<P>

<BLOCKQUOTE>
<STRONG>Chapter summary</STRONG>:<BR>
General utilities are often handy.  VBL has a few.
</BLOCKQUOTE>
<P>

All C++ programs need a few basic utilities, and all C++ programmers write
their own at some point.  The things included in vbl are not considered any
better or worse than the several other libraries available, but they are
consistently named and lightweight.  The key elements of this library
are
</P><P>

<A NAME="IDX6"></A>
<DL>
<DT><U>class template:</U> <B><CODE>vbl_smart_ptr</CODE></B>
<DD>Reference counted smart pointers for any class that defines <CODE>ref</CODE> and
<CODE>unref</CODE>.
</DL>
</P><P>

<A NAME="IDX7"></A>
<DL>
<DT><U>class:</U> <B><CODE>vbl_file</CODE></B>
<DD><A NAME="IDX8"></A>
<DT><U>class:</U> <B><CODE>vbl_directory</CODE></B>
<DD>File handling utilities, directory reading
</DL>
</P><P>

<A NAME="IDX9"></A>
<DL>
<DT><U>class template:</U> <B><CODE>vbl_arg</CODE></B>
<DD>Parse command-line arguments conveniently.
</DL>
</P><P>

<A NAME="IDX10"></A>
<DL>
<DT><U>class:</U> <B><CODE>vbl_redirector</CODE></B>
<DD>Simplify redirection of cout/cerr
</DL>
</P><P>

<A NAME="IDX11"></A>
<DL>
<DT><U>class:</U> <B><CODE>vbl_awk</CODE></B>
<DD>Read text files, breaking each line into fields.
</DL>
</P><P>

<A NAME="IDX12"></A>
<DL>
<DT><U>class:</U> <B><CODE>vbl_reg_exp</CODE></B>
<DD>Regular expression matching.
</DL>
</P><P>

<HR SIZE="6">
<A NAME="SEC19"></A>
<H2> 3.1 Redirecting standard output: <CODE>vbl_redirector</CODE> </H2>
<!--docid::SEC19::-->
<A NAME="vbl_redirector"></A>
<P>

The class <CODE>vbl_redirector</CODE> is provided to simplify the task of
filtering the output of <CODE>cerr</CODE> and <CODE>cout</CODE>, a common requirement
in graphical applications.  This encapsulates some of the subtleties of
subclassing from <CODE>streambuf</CODE>, providing a simpler interface.
</P><P>

The basic usage is to subclass from <CODE>vbl_redirector</CODE>, implementing the
<CODE>putchunk</CODE> method, which is then called whenever characters are ready
for output.  The <CODE>vbl_redirector</CODE> constructor takes care of attaching
the new buffer to the stream, and of restoring the original behaviour on
destruction.  Here is a simple example, which switches output on or off
depending on the value of a global flag;
<TABLE><tr><td>&nbsp;</td><td class=example><pre>
#include &#60;vbl/vbl_redirector.h&#62;

bool on = true;

struct my_redirector : public vbl_redirector {
  my_redirector(vcl_ostream&#38; s): vbl_redirector(s) {}
  int putchunk(char const* buf, int n) {
    if (on)
      return vbl_redirector::put_passthru(buf, n);
    else
      return n;
  }
};
</pre></td></tr></table>and here is a calling program which exercises the example.
<TABLE><tr><td>&nbsp;</td><td class=example><pre>int main(int argc, char* argv[])
{
  cerr &#60;&#60; "hi\n";
  {
    my_redirector redir(cerr);
    on = false;
    cerr &#60;&#60; "magic\n";
  }
  cerr &#60;&#60; "what did I miss?\n";
  return 0;
}
</pre></td></tr></table></P><P>

When this program is run, the word <CODE>magic</CODE> is not displayed, because
<CODE>my_redirector::putchunk</CODE> finds that <CODE>on == false</CODE>.  Question,
what to you think <CODE>put_passthru</CODE> does?  What happens if you set
<CODE>on = true</CODE> on line 6?
</P><P>

<HR SIZE="6">
<A NAME="SEC20"></A>
<H2> 3.2 Complex output formatting: <CODE>vbl_printf</CODE> </H2>
<!--docid::SEC20::-->
<P>

While it is possible to achieve all of the functionality
of the C <CODE>printf</CODE> function in C++, it is very very difficult.
There are many times when programs can be made clearer by the use
of printf formatting, rather than the standard iostream operators.
On the other hand, one needs iostreams for type-safe (and convenient)
output of user-defined objects.  Thus vbl provides a stream-aware
version, <CODE>vbl_printf</CODE>:
<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>vcl_ostream&#38; vbl_printf(vcl_ostream&#38;, char const* format, ...);
</FONT></pre></td></tr></table>so that one can say, for example,
<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>vbl_printf(vcl_cerr, "Line %05d, Code %-30s\n", __LINE__, code);
</FONT></pre></td></tr></table></P><P>

<HR SIZE="6">
<A NAME="SEC21"></A>
<H2> 3.3 Reading command-line arguments: <CODE>vbl_arg</CODE> </H2>
<!--docid::SEC21::-->
<P>

My favourite bit of vbl is the <CODE>vbl_arg</CODE> header which provides the
easiest way to parse command-line arguments that I've seen.  The basic idea
is that a minimal specification for a command-line argument includes: the
argument's type, a variable to hold it, its flag, and possibly some
descriptive text and a default value.
</P><P>

In the default, easy to use (and a bit naughty) form, each argument is
declared anywhere in the program, like so:
<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>   vbl_arg&#60;double&#62; my_threshold("-fudge", "Twiddle fudge", 1.7);
   //     Type     Variable     Flag      Help text        Default
</FONT></pre></td></tr></table>and when <CODE>vbl_arg_parse</CODE> is called, all the arguments are gathered,
and extracted from the command line.  To use an argument anywhere in the
program, use its <CODE>()</CODE> operator:
<TABLE><tr><td>&nbsp;</td><td class=example><pre>   vcl_cerr &#60;&#60; "The threshold = " &#60;&#60; my_threshold() &#60;&#60; vcl_endl;
</pre></td></tr></table>To check if an argument was changed from its default value, one can check
<CODE>bool my_naughty_threshold.set()</CODE>.
</P><P>

Here is a complete example which uses <CODE>vbl_arg</CODE>.  I tend to give these
argument variables names beginning with <CODE>a_</CODE>, but don't let that put
you off.
<TABLE><tr><td>&nbsp;</td><td class=example><pre>#include &#60;vcl/vcl_iostream.h&#62;
#include &#60;vbl/vbl_arg.h&#62;

vbl_arg&#60;double&#62; a_naughty_global_arg("-hack", "Fudge", 1.2);

void main(int argc, char* argv[])
{
  vbl_arg&#60;char const*&#62;     a_filename(0, "Input filename");
  vbl_arg&#60;bool&#62;            a_fast("-fast", "Go fast", false);
  vbl_arg_parse(argc, argv);

  vcl_cerr &#60;&#60; "Filename [" <&#60; a_filename() &#60;&#60; "]\n";
}
</pre></td></tr></table>Passing a <CODE>0</CODE> as the flag string means that the argument is
obligatory, and will be taken as the first unparsed word on the command
line.
</P><P>

<HR SIZE="6">
<A NAME="SEC22"></A>
<H3> 3.3.1 Help text </H3>
<!--docid::SEC22::-->
The help text supplied with each argument is used to provide a summary of
options when the special argument <CODE>-?</CODE> is seen.  Running this example
with the <CODE>-?</CODE> flag produces the output.
<P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>Usage: ./example_vbl_arg.exe [-hack float] string [-fast bool]

REQUIRED:
         string       Input filename  ['-']

Optional:
  Switch Type         Help [value]

   -hack float        Quick hack factor  [1.2]
   -fast bool         Go fast  [not set]
</FONT></pre></td></tr></table></P><P>

<HR SIZE="6">
<A NAME="SEC23"></A>
<H3> 3.3.2 Lists of numbers </H3>
<!--docid::SEC23::-->
A very useful specialization also exists to read ranges of numbers.
Imagine a progam called makemovie which operates on a list of frames,
specified on the command line:
<TABLE><tr><td>&nbsp;</td><td class=example><pre>makemovie -frames 1:10,9:-1:1,0,0,0,0
</pre></td></tr></table>These can be easily read into a <CODE>vcl_list&#60;int&#62;</CODE>:
<TABLE><tr><td>&nbsp;</td><td class=example><pre>#include &#60;vcl/vcl_list.h&#62;
vbl_arg&#60;vcl_list&#60;int&#62; &#62;  a_frame_list("-frames", "List of indices");
</pre></td></tr></table>The list will preserve the order specified on the command line, so in the
above example, the result of printing the list would be
<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>1 2 3 4 5 6 7 8 9 10 9 8 7 6 5 4 3 2 1 0 0 0 0
</FONT></pre></td></tr></table>As a gratuitous STL example, here is the code that printed that list
<A NAME="IDX13"></A>
<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>vcl_copy(a_frame_list().begin(), a_frame_list().end(),
         vcl_ostream_iterator&#60;int&#62;(vcl_cout, " "));
</FONT></pre></td></tr></table><P>

<HR SIZE="6">
<A NAME="SEC24"></A>
<H3> 3.3.3 More structured argument handling </H3>
<!--docid::SEC24::-->
Of course, it's disgraceful programming practice to throw args around ones
program higgledy piggledy, so one can collect arguments in objects of type
<CODE>vbl_arg_list</CODE>.
<P>

<HR SIZE="6">
<A NAME="SEC25"></A>
<H2> 3.4 Reading ASCII files: <CODE>vbl_awk</CODE> </H2>
<!--docid::SEC25::-->
<P>

It is often convenient to read text files a line at a time, and split each
line into space-separated fields.  The <CODE>vbl_awk</CODE> class is an easy way
to do this.  It also adds a few handy extras like stripping comments, and
remembering the line number for error messages.  It is used like this:
<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>   vcl_ifstream thefile("myfile.txt");
   vbl_awk awk(thefile); // initialize and read 1st line
   for(;awk; ++awk) {
     vcl_cerr &#60;&#60; "Field 0 = " &#60;&#60; awk[0] &#60;&#60; vcl_endl;
     vcl_cerr &#60;&#60; "Field 2 = " &#60;&#60; awk[2] &#60;&#60; vcl_endl;
   }
</FONT></pre></td></tr></table></P><P>

<HR SIZE="6">
<A NAME="SEC26"></A>
<H2> 3.5 Regular expression parsing: <CODE>vbl_reg_exp</CODE> </H2>
<!--docid::SEC26::-->
<P>

<A NAME="vnl"></A>
<HR SIZE="6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[ &lt;&lt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[ &gt;&gt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book_11.html#SEC56">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
</BODY>
</HTML>
