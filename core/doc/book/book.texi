\input atexinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename vxl.info
@settitle VXL
@setchapternewpage odd
@paragraphindent 0
@c Set up printed page layout.
@iftex
@afourlatex
@end iftex


@c Define the @caption{1} macro
@ifnottex
@macro caption{figurenumber}
@quotation
@strong{Figure \figurenumber\:}
@end macro
@macro endcaption
@end quotation
@end macro
@macro figure
@end macro
@end ifnottex

@c Define the chapsummary macro
@ifnottex
@macro chapsummary
@quotation
@strong{Chapter summary}:@*
@c @cartouche
@end macro

@macro endchapsummary
@c @end cartouche
@end quotation
@end macro
@end ifnottex

@iftex
@tex
\gdef\chapsummary{
@quotation
@cartouche
@strong{Chapter summary}:
}
\gdef\endchapsummary{
@Ecartouche
@Equotation
}
@end tex
@end iftex

@c Define the @vxl{} macro.  v, slanted x, l
@iftex
@macro vxl
v{@sl x}l
@end macro
@end iftex
@ifnottex
@macro vxl
vxl
@end macro
@ifhtml
@macro vxl
v@emph{x}l
@end macro
@end ifhtml
@end ifnottex

@c Define the @LaTeX{} macro
@iftex
@tex
\gdef@LaTeX{L\kern-.36em%
        {\setbox0\hbox{T}\vbox to\ht0{\hbox{\smallrm A}\vss}}%
        \kern-.15em\TeX}
@end tex
@end iftex
@ifnottex
@macro LaTeX
LaTeX
@end macro
@end ifnottex

@c Define the @inputclass{name} macro
@macro inputclass{name}
inputclass \name\
@end macro

@c Define @ttb{text}: teletype bold 
@iftex
@macro ttb{text}
@newdimen@ttbskip@ttbskip=.5pt@c
@setbox0@hbox{@kern-0.5em\text\}@c
@copy0@kern-@wd0@kern@ttbskip@unhbox0@kern-@ttbskip@c
@end macro
@end iftex
@ifnottex
@macro ttb{text}
@strong{\text\}
@end macro
@end ifnottex

@c %**end of header

@c -----------------------------------------------------------------------------

@node Top, Introduction, , (dir)

@ifinfo
This documents the VXL collection of C++ libraries.

Copyright 2000 The TargetJr Consortium

Permission is granted to copy and distribute, retaining this
original copyright notice.
@end ifinfo

@c  This title page illustrates only one of the
@c  two methods of forming a title page.

@iftex
@titlepage
@title V@emph{X}L
@subtitle A collection of C++ libraries for computer vision.
@author The TargetJr Consortium

@c  The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2000 Andrew Fitzgibbon
@end titlepage
@shortcontents
@contents
@end iftex

@menu
* Introduction::
* vbl::
* vnl::
* vil::
* vgl::
* vgui::
* Conclusion::
* Concept Index::
@end menu

@node    Introduction, vbl, top,      top
@comment node-name, next,           previous, up
@chapter Introduction
@cindex Introduction
@cindex IUE
@cindex TargetJr

@chapsummary
 VXL is efficient, simple, and fun to use.
@endchapsummary

This document describes @vxl{}, a collection of C++ libraries designed for
computer vision research.  Because it's for computer vision it needs to be
@emph{efficient}, handling large quantities of numerical data with little
overhead.  Because it's for research it must be @emph{portable}, so that
one can write and run one's program on any machine available, for example
in order to access a special camera or fast image processing hardware.

The @vxl{} collection's portability and efficiency are traits which are due
in large part to its parentage.  The package was built by extracting the
core functionalities of two large systems: the ``Image Understanding
Environment'' (IUE) and ``Target junior'' (TargetJr).  Although these
environments contained a wealth of useful code, and have facilitated much
research, they are widely known for their bulk, and the difficulty of
learning to use them.  Common complaints have been
@itemize @bullet
@item
``Too heavy'': To use even one small routine, a large portion of the
environment must be included in the user's program, increasing program
size, compile time, and startup time.  Sometimes the increase is such that
debuggers and other tools fail to work.
@item
``Too slow'': In some cases, the design of the earlier systems restricted
the efficiency of code that could be written when using them.  This was in
some part due to deficiencies of the C++ compilers in use, but also due to
the use of since-superseded programming paradigms.
@item
``Too weird'': Because the IUE is a large system, intended to be used as a
programming environment, it imposes stylistic quirks on programmers who use
it.  The most apparent of these was the use of @LaTeX{} to generate code,
which offered many benefits, but was ultimately rejected by users.
@end itemize
Despite these complaints, the quality of the software available in the
environments, and the promise of a sustained, concerted software
development effort has meant that the IUE/TargetJr has many users
worldwide.  The job of @vxl{} is to make that many @emph{happy} users, by
creating a set of libraries which have the same useful code, but which are
light, fast, and not weird.

@section Contents

The core of @vxl{} was defined in Feburary 2000, and comprises five
libraries.

@subsection vcl: The C++ compatibility layer.

The job of vcl is to turn your compiler into a standard C++ compiler.  In
particular, it ensures that your standard library behaves at least
something like that defined in the ANSI/ISO standard.  In an ideal world,
vcl would not be necessary, as all compiler vendors would ship perfectly
compliant systems.  But then, in a perfect world, C++ wouldn't be the only
choice for high efficiency high-level programming.

@subsection vbl: Basics.
The basics library contains a small set of generally useful C++ classes and
functions, notably smart pointers, file and directory handling,
command-line argument parser, string utilities, a timer, etc.

@subsection vnl: Numerical algorithms.
The main classes in vnl are the matrix and vector classes, which are very
simple c-like objects.  There is no reference counting, objects are
returned by value, or passed into routines.  The use of objects to hold the
output of matrix decompositions also reduces the amount of copying that
needs to be done.  The numerical algorithms are wrappers around
public-domain, high quality Fortran code from the TargetJr @code{netlib}
library.

@subsection vil: Imaging.
The imaging library is designed to work well with very large images, but
its primary design objective is to be fast and convenient for the typical
in-core images that are encountered in video and digital image processing.
A panoply of file formats is handled, and it is easy to add support for a
new format.

@subsection vgl: Geometry.
It is in geometry that the spartan aesthetic of the core of @vxl{} becomes
most apparent.  The library deals with the geometry of points, curves, and
other objects in 2 or more dimensions, but may not call on the numerics
library.  Therefore, it is  restricted to operations which it is reaonable
to express in standard C++, which places a useful limit on what may be
placed there.  For example, surface fitting cannot be in geometry as it
would require the singular value decomposition.  However, there is much
here that is useful, and the library is quite large enough already.  The
@code{vgl_algo} library contains the higher-level code.

@section Documentation
@cindex book
@cindex documentation, monolithic
The @vxl{} documentation comes in two main forms: this book, and structured
comments in the source code, which are automatically extracted.  The book
is intended to be a single reference, where all the high-level
documentation resides.   In TargetJr and the IUE there was always a problem
finding documentation, as it was in too many places.  In @vxl{}, we are
following the practice of some other successful systems such as vtk, and
providing one monolithic document with, we hope, a good index.

@c The principle is almost the opposite of that in the code itself.

@subsection The VXL Book

The book (in subdirectory book) is a human-written collection of VXL
documentation, suitable for printing.  It is intended to be readable as an
introduction to the various facilities provided by the @vxl{} libraries,
and the be browsable as a first source of examples and tips.

@subsubheading Why texinfo?
@cindex texinfo
It is written in texinfo, a limited form of LaTeX which allows us to make
various forms of output: printed, HTML, windows help files, emacs info, and
plain text files.  Each of these forms has its adherents, and each is
useful.  There are other documentation systems which allow multiple output
formats, but none match texinfo in the three main formats: paper,
hypertext, and ASCII.  This is because it's difficult to target such
disparate formats, and texinfo has evolved over many years to do it well.

On the other hand, texinfo is hard to learn for those who don't know @TeX{}
or @LaTeX{}, so we are keeping an eye on formats such as @emph{DocBook}.

@subsection Automatically generated documentation
@cindex documentation, automatically generated
@cindex doxygen

Although the human-written @vxl{} book is the first source, the definitive
authority on what a class or function does must be the source code
comments.  The book will give a high-level description of the most
important and commonly-used features of a class, but the source code
contains the details.  In order to make these details easier to scan, the
@vxl{} source files contain specially structured comments, which can be
scanned by the @emph{Doxygen} program and converted into an attractive
hyperlinked reference.

An example of what the syntax for documentation looks like can be found
in @code{vxl/doc/vxl_doc_rules.[h,cxx]}, but briefly a comment line which
begins with @code{//:} is documentation for the type, function, or
variable which follows it.  For example

@smallexample
//: Brief description of my_class
class my_class @{
  //: \brief Brief description, the long one is in the .cxx file
  my_class();
@};
@end smallexample


@section The Design and Evolution of @vxl{}

Design goals:

@itemize @bullet
@item Cross platform

@item Loosely coupled

@item light weight --- simple interfaces

@item high-powered --- allow infinitely large images.

@item uniform naming -- of course.
@end itemize

@subsection Motivation
In OpenGL, you guess the name of something, and you're generally
right.  This is what we would like to achieve with @vxl{}.

@cindex C, similarity to C libraries
Simple and free of programming dogma.  For example, many @vxl{} routines
exist as C-like functions.  For some tasks, C-like
functions are more appropriate than a forced object-orientation, for others
objects are clearly the more intuitive and compact representation.  This is
clearly seen in the imaging library, where the @code{vil_image} object is
passed to and returned from C-like functions, for example
@example
  vil_image i = vil_load(filename);
  i = vil_smooth_gaussian(i, 0.6);
  vil_save(i, out_filename, "pnm");
@end example
In this case, object orientation ensures that memory is managed
efficiently, without unnecessary copying of data, while using functions
makes the code more readable.

When building a large system, it is crucial to maintain consistent
conventions for file-system structure, and identifier naming.  However, a
crucial philosophy in the design of @vxl{} is that system conventions must
be pragmatic.  If programmers are ultimately constrained rather than helped
by their environment, they will break the rules, and when they do so, they
will break them in inconsistent ways.  Therefore it is crucial that
consistency within the environment is achieved by conventions that are easy
to live with.  One example, discussed below, is in the rule governing the
relationship between header file names and the objects defined within that
header.  The general principle, then, is "as close to consistent as
comfortable, but no more".

@subsection Names

Names are always the biggest issue in programming environments.  Uniform
naming is one of the most important aspects of a library, and part of the
design effort in @vxl{} lay in choosing a good, workable scheme for the
naming of classes, functions and files.  On the other hand, few issues
cause as much debate as the choice of naming conventionts.  However, we are
lucky for two reasons: first, because we wish to run cross-platform, many
options are restricted; second, as we can never please everybody, we can
just choose a convention and pretend we all hate it.

First things first.  The name @vxl{} itself refers to a collection of
libraries where the @emph{x} is replaced by a one or two-letter code
describing the contents.

Second, do we use @code{MixedCaseIdentifiers} or
@code{lowercase_with_underscores}?   Well, a certain operating system
#defines 1300 of the @code{MixedCaseIdentifiers} in a header file.
Therefore, programs which use names like @code{LoadImage} may or may not
link.  For this reason, we chose the other ugly solution.

@cindex file extensions
@cindex cxx
@cindex txx
For related reasons, source files in @vxl{} all end in @code{.cxx}.
Template definitions, which are essentially header files (as they are not
separately compiled) but look like source files, are suffixed @code{.txx}.

Each class or function in a @vxl{} library begins with the name of that
library, for example @code{vnl_matrix}.  This makes it easy to locate the
source code for any class, and easy to see the list of libraries on which
one's program depends.

@cindex namespaces, why not
This scheme was chosen over namespaces because few compilers support
namespaces well, and their implications in large-scale development are as
yet poorly understood.

An obvious extension of this convention would be to insist that every class
or function (in fact, every globally visible symbol exported by a library),
should be defined in its own include file, yielding an easy relationship
between symbols and include statements.  However, such a scheme
imposes great demands on programmers, who must generate long lists of
includes, and on library writers who must create many files with very
little in each.  Pragmatism must rule if we are to avoid programmer
discomfort, thus chaos.  A rule that is still useful, and easier to adhere
to is used:
@quotation
The file @code{vxl/vxl_stuff.h} exports only identifiers which
begin @code{vxl_stuff}.
@end quotation
An example of a header file which obeys this rule is shown in figure 1.

@figure
@cartouche
@smallexample
#ifndef vxl_stuff_h_
#define vxl_stuff_h_

enum vxl_stuff_things @{
  vxl_stuff_bare,
  vxl_stuff_spartan
@};

class vxl_stuff @{
@};

bool vxl_stuff_grok(vxl_stuff);
extern int vxl_stuffing;

#endif
@end smallexample
@end cartouche
@caption{1}
Example of a header file @code{vxl_stuff.h} which obeys the naming
convention. Only identifiers that begin with @code{vxl_stuff} may be
defined.
@endcaption

@end figure

Of course, this rule is less helpful to clients of the library, who might
remember that there is a class called @code{vtl_thing_doer}, but not know
which header file to include.  However, the disadvantage is not great, as
the likely options are just @code{vtl/vtl_thing.h} and
@code{vtl/vtl_thing_doer.h}.  What is ultimately helpful to clients is a
uniform naming scheme, kept so by pragmatic constraints on the library
developers.

FAQ: What about @code{operator+(vcl_stuff, vcl_stuff)}?  Frequently given
half-answer: Koenig lookup means it's OK.


@subsection Layering
@cindex levels, library layering
@cindex layering
@cindex library interdependencies
Which brings us on to layering: core @vxl{} libraries may not depend on
each other.  The numerics library cannot use the handy string manipulation
in vbl, the imaging library cannot use matrices, or smart pointers.  This
restriction is central to the design of @vxl{}, because it intrinsically
limits the size of the core libraries.
It appears to contradict traditional software development practice because
it implies that code will be duplicated rather than reused.  However,
the amount of code duplicated is small, and the benefit of lego libraries
is enormous.   The current status is encapsulated in this figure
@example
Level:   0         1         2          3
         vcl       vbl       vnl_algo   v**l
                   vnl       vil_algo
                   vil       vgl_algo
                   vgl
@end example
@quotation
Library layers: libraries in one layer may not call their
siblings, even if this means code copying.
@end quotation

However, other alternatives have been considered, and may yet be
considered.  For example, what about putting vbl at level 0.5, so that
common utilities can be available to level 1?  The problem of course is
that everything will end up in the level 0.5 library.  We could impose the
rule that nothing goes in vbl unless it is used in at least two level 1
libraries.  I don't know whether that would help or not...

@comment ------------------------------------------------------------------
@node    vcl,       vbl,  Introduction, top
@comment node-name, next, previous,     up
@chapter vcl: C++ compatibility
@cindex vcl
@cindex ANSI/ISO C++
@cindex SCL
@cindex Standard C++ library

@chapsummary
When you want a @code{std::string}, use @code{vcl_string}.
@endchapsummary

The job of vcl is to fix your compiler.  C++ is not just a language; the
standard also includes an extensive library of classes and functions, which
make ISO C++ a powerful and useful tool for building computer programs.
Unfortunately, few C++ compilers available in 2000 have a bug-free
implementation of the standard, so we have to supply our own bug fixes.

To give an example of the type of problems that vcl fixes, here are a few
interpretations from the standard which have been observed in some well
known vendors' libraries.  Many are entirely within the letter of the law,
but remain prone to introduce confusion.

On one compiler, @code{<iostream>} and @code{<iostream.h>} refer to
entirely different stream libraries, which may not be linked together.
Therefore every file in the program must use the same header.  For us, the
@code{<iostream>} version is appropriate, but of course, not all of the
unix compilers support its use.  The solution is for every @vxl{} program
to include @code{<vcl/vcl_iostream.h>}.  In this way, we can maintain
consistency between the many compilers, and if we ever do need to use
another stream library, we can make the switch in one place.
Thus rule one is
@quotation
Wherever you wish to include standard header @code{<foo>}, you should
include @code{<vcl/vcl_foo.h>} instead.
@end quotation

Some compilers place STL classes such as @code{vector} and @code{vcl_string} in
namespace @code{std}, some don't.  Yet others place them there, but do not
implement namespaces properly.  Therefore, it is very difficult to write
portable code because sometimes one must say @code{std::vector}, sometimes
one must use @code{vector}.  Again, we need a way which works on all
systems.  We could try to insert @code{using namespace std;} or @code{using
std::vector} commands throughout the program, but (a) this is not
considered good C++, and (b) it doesn't work anyway.

The low-tech solution is simply to prefix each standard identifier with
@code{vcl_}, so that @code{vcl_vector} works everywhere.  And this is
what @vxl {} does, when you include @code{<vcl/vcl_vector.h>}.  Thus, safe
programmers prefix @emph{everything} in the standard library with
@code{vcl_}.
@quotation
Wherever you wish to use standard class or function @code{foo}, you should
write @code{vcl_foo} instead.
@end quotation
This may seem excessive, but one gets used to it very quickly, and it
quickly indicates to novice C++ programmers which functions are from the
standard library.  You might think that the designers of @vxl{} would have
been clever enough to avoid the vcl_ prefix by using fancy compiler flags,
and many #defines.  However, that way lies madness---trying to confuse a
C++ compiler always rebounds on one.

@section Example
This program is exemplary.  It shows how every identifier in the ISO
library has been prefixed by @code{vcl_}.  It may look like extreme
overkill, but it works, and can be made to work on all compilers we've
seen.
@example
#include <vcl/vcl_string.h>
#include <vcl/vcl_iostream.h>
#include <vcl/vcl_vector.h>
#include <vcl/vcl_algorithm.h>

int main()
@{
  vcl_vector<vcl_string> strings;
  strings.push_back("Hello, ");
  strings.push_back("World.");
  vcl_copy(strings.begin(), strings.end(),
           vcl_ostream_iterator<vcl_string>(vcl_cout));
  return 0;
@}
@end example
The alternative is somewhat scary.  It begins
@smallexample
#if defined(_WIN32) || (defined(__SUNPRO_CC) && (__SUNPRO_CC + 0) >= 0x500)
#include <string>
#else
#include ...
@end smallexample

This document has little more to say about the contents of VCL---a book on
C++ should describe it better than we can.  However, it is important to
note that nothing more can go in there.  If it's not in the standard, it's
not in VCL.  Remember, VCL is full, nothing else can go in there.  It
cannot for example be ``helpfully'' modified, Microsoft-style, to send
standard error to a window (but @pxref{vbl_redirector}).


@comment ------------------------------------------------------------------
@node    vbl, vnl, Introduction,      top
@comment node-name, next,           previous, up
@chapter vbl: Basics
@cindex vbl
@cindex basics
@cindex general utilities

@chapsummary
General utilities are often handy.  VBL has a few.
@endchapsummary


All C++ programs need a few basic utilities, and all C++ programmers write
their own at some point.  The things included in vbl are not considered any
better or worse than the several other libraries available, but they are
consistently named and lightweight.  The key elements of this library
are

@deffn {class template} @code{vbl_smart_ptr}
Reference counted smart pointers for any class that defines @code{ref} and
@code{unref}.
@end deffn

@deffn class @code{vbl_file}
@deffnx class @code{vbl_directory}
File handling utilities, directory reading
@end deffn

@deffn {class template} @code{vbl_arg}
Parse command-line arguments conveniently.
@end deffn

@deffn class @code{vbl_redirector}
Simplify redirection of cout/cerr
@end deffn

@deffn class @code{vbl_awk}
Read text files, breaking each line into fields.
@end deffn

@deffn class @code{vbl_reg_exp}
Regular expression matching.
@end deffn

@section Redirecting standard output: @code{vbl_redirector}
@cindex cerr
@cindex cout
@cindex redirecting ostreams
@cindex vbl_redirector
@anchor{vbl_redirector}

The class @code{vbl_redirector} is provided to simplify the task of
filtering the output of @code{cerr} and @code{cout}, a common requirement
in graphical applications.  This encapsulates some of the subtleties of
subclassing from @code{streambuf}, providing a simpler interface.

The basic usage is to subclass from @code{vbl_redirector}, implementing the
@code{putchunk} method, which is then called whenever characters are ready
for output.  The @code{vbl_redirector} constructor takes care of attaching
the new buffer to the stream, and of restoring the original behaviour on
destruction.  Here is a simple example, which switches output on or off
depending on the value of a global flag;
@example

#include <vbl/vbl_redirector.h>

bool on = true;

struct my_redirector : public vbl_redirector @{
  my_redirector(vcl_ostream& s): vbl_redirector(s) @{@}
  int putchunk(char const* buf, int n) @{
    if (on)
      return vbl_redirector::put_passthru(buf, n);
    else
      return n;
  @}
@};
@end example
and here is a calling program which exercises the example.
@example
int main(int argc, char* argv[])
@{
  cerr << "hi\n";
  @{
    my_redirector redir(cerr);
    on = false;
    cerr << "magic\n";
  @}
  cerr << "what did I miss?\n";
  return 0;
@}
@end example

When this program is run, the word @code{magic} is not displayed, because
@code{my_redirector::putchunk} finds that @code{on == false}.  Question,
what to you think @code{put_passthru} does?  What happens if you set
@code{on = true} on line 6?



@section Complex output formatting: @code{vbl_printf}
@cindex printf
@cindex vbl_printf

While it is possible to achieve all of the functionality
of the C @code{printf} function in C++, it is very very difficult.
There are many times when programs can be made clearer by the use
of printf formatting, rather than the standard iostream operators.
On the other hand, one needs iostreams for type-safe (and convenient)
output of user-defined objects.  Thus vbl provides a stream-aware
version, @code{vbl_printf}:
@smallexample
vcl_ostream& vbl_printf(vcl_ostream&, char const* format, ...);
@end smallexample
so that one can say, for example,
@smallexample
vbl_printf(vcl_cerr, "Line %05d, Code %-30s\n", __LINE__, code);
@end smallexample




@section Reading command-line arguments: @code{vbl_arg}
@cindex argc, argv
@cindex vbl_arg
@cindex command-line arguments, reading
@cindex ArgParse, new name vbl_arg
@cindex Arg, new name vbl_arg

My favourite bit of vbl is the @code{vbl_arg} header which provides the
easiest way to parse command-line arguments that I've seen.  The basic idea
is that a minimal specification for a command-line argument includes: the
argument's type, a variable to hold it, its flag, and possibly some
descriptive text and a default value.

In the default, easy to use (and a bit naughty) form, each argument is
declared anywhere in the program, like so:
@smallexample
   vbl_arg<double> my_threshold("-fudge", "Twiddle fudge", 1.7);
   //     Type     Variable     Flag      Help text        Default
@end smallexample
and when @code{vbl_arg_parse} is called, all the arguments are gathered,
and extracted from the command line.  To use an argument anywhere in the
program, use its @code{()} operator:
@example
   vcl_cerr << "The threshold = " << my_threshold() << vcl_endl;
@end example
To check if an argument was changed from its default value, one can check
@code{bool my_naughty_threshold.set()}.

Here is a complete example which uses @code{vbl_arg}.  I tend to give these
argument variables names beginning with @code{a_}, but don't let that put
you off.
@example
#include <vcl/vcl_iostream.h>
#include <vbl/vbl_arg.h>

vbl_arg<double> a_naughty_global_arg("-hack", "Fudge", 1.2);

void main(int argc, char* argv[])
@{
  vbl_arg<char const*>     a_filename(0, "Input filename");
  vbl_arg<bool>            a_fast("-fast", "Go fast", false);
  vbl_arg_parse(argc, argv);

  vcl_cerr << "Filename [" << a_filename() << "]\n";
@}
@end example
Passing a @code{0} as the flag string means that the argument is
obligatory, and will be taken as the first unparsed word on the command
line.

@subsection Help text
The help text supplied with each argument is used to provide a summary of
options when the special argument @code{-?} is seen.  Running this example
with the @code{-?} flag produces the output.

@smallexample
Usage: ./example_vbl_arg.exe [-hack float] string [-fast bool]

REQUIRED:
         string       Input filename  ['-']

Optional:
  Switch Type         Help [value]

   -hack float        Quick hack factor  [1.2]
   -fast bool         Go fast  [not set]
@end smallexample

@subsection Lists of numbers
A very useful specialization also exists to read ranges of numbers.
Imagine a progam called makemovie which operates on a list of frames,
specified on the command line:
@example
makemovie -frames 1:10,9:-1:1,0,0,0,0
@end example
These can be easily read into a @code{vcl_list<int>}:
@example
#include <vcl/vcl_list.h>
vbl_arg<vcl_list<int> >  a_frame_list("-frames", "List of indices");
@end example
The list will preserve the order specified on the command line, so in the
above example, the result of printing the list would be
@smallexample
1 2 3 4 5 6 7 8 9 10 9 8 7 6 5 4 3 2 1 0 0 0 0
@end smallexample
As a gratuitous STL example, here is the code that printed that list
@cindex STL: copy example
@smallexample
vcl_copy(a_frame_list().begin(), a_frame_list().end(),
         vcl_ostream_iterator<int>(vcl_cout, " "));
@end smallexample


@subsection More structured argument handling
Of course, it's disgraceful programming practice to throw args around ones
program higgledy piggledy, so one can collect arguments in objects of type
@code{vbl_arg_list}.


@section Timing operations: vbl_timer
@cindex time, measuring elapsed
@cindex vbl_timer
@cindex cpu time

If you want to measure elapsed time, for example to find out how long a
section of your program takes to run, use the @code{vbl_timer} class.  When
a @code{vbl_timer} is initialized, like so, it records the current time.
@example
   vbl_timer mytimer;
@end example
Later, you can find out the elapsed time using the @code{real()} method:
@example
   vcl_cerr << "That took " << mytimer.real() << " milliseconds\n";
@end example
If you want to reset the timer to make a new measurement, use the
@code{mark()} method.
@example
   mytimer.mark();  // Reset and start counting from zero again.
@end example

If you are running other jobs on your computer, you might like to know how
much time was used by your program alone.  For that, one would use the
@code{user()} method.
@example
   vcl_cerr << "Of which " << mytimer.user() << "ms was actually me\n";
@end example
In general, it is better to use the @code{real}, ``wall-clock'' elapsed
time, as the CPU time returned by user can fail to include work carried out
on your program's behalf by the operating system.  For example, if you're
using a lot of memory, the system will swap pages in and out of virtual
memory, and your program will run slowly, but @code{user()} will not report
it.

Finally, there's a super-convienient @code{print} method, which is used
to just print the real and user times to a stream without any
formatting, for quick testing purposes.  Here's an example
@example
  vbl_timer tic; // Start timing
  // do stuff
  tic.print(vcl_cerr); // Print times to cerr.
@end example



@section Reading ASCII files: @code{vbl_awk}
@cindex awk
@cindex perl-like operations: vbl_awk
@cindex file handling: vbl_awk

It is often convenient to read text files a line at a time, and split each
line into space-separated fields.  The @code{vbl_awk} class is an easy way
to do this.  It also adds a few handy extras like stripping comments, and
remembering the line number for error messages.  It is used like this:
@smallexample
   vcl_ifstream thefile("myfile.txt");
   vbl_awk awk(thefile); // initialize and read 1st line
   for(;awk; ++awk) @{
     vcl_cerr << "Field 0 = " << awk[0] << vcl_endl;
     vcl_cerr << "Field 2 = " << awk[2] << vcl_endl;
   @}
@end smallexample


@section Regular expression parsing: @code{vbl_reg_exp}
@cindex regular expressions
@cindex vbl_reg_exp
A regular expression allows a programmer to specify complex patterns that
can be searched for and matched against the character string of a string
object. In its simplest form, a regular expression is a sequence of
characters used to search for exact character matches. However, many times
the exact sequence to be found is not known, or only a match at the
beginning or end of a string is desired. The vbl regular expression class
implements regular expression pattern matching as is found and implemented
in many UNIX commands and utilities, notably perl.  The perl code
@example
   $filename =~ m"([a-z]+)\.h";
   print $1;
@end example
is written as follows in @vxl{}
@example
   vbl_reg_exp re("([a-z]+)\\.h");
   re.find(filename);
   cerr << re.match(1);
@end example

The vbl syntax is similar to perl's, although not quite as clean.  Here are
the metacharacters:
@example
 ^        Matches at beginning of a line
 $        Matches at end of a line
 .        Matches any single character
[ ]       Matches any character(s) inside the brackets
[^ ]      Matches any character(s) not inside the brackets
 -        Matches any character in range on either side of a dash
 *        Matches preceding pattern zero or more times
 +        Matches preceding pattern one or more times
 ?        Matches preceding pattern zero or once only
()        Saves a matched expression and uses it in a later match.
@end example
Note that more than one of these metacharacters can be used in a single
regular expression in order to create complex search patterns. For example,
the pattern @code{[^ab1-9]} says to match any character sequence that does
not begin with the characters "ab" followed by numbers in the series 1-9.

@comment ------------------------------------------------------------------
@node    vnl,       vil,  vbl,      top
@comment node-name, next, previous, up
@chapter vnl: Numerics
@cindex vnl
@cindex Numerics

@chapsummary
C++ @emph{can} be like Matlab, but faster and more powerful.
@endchapsummary


The numerics library, @code{vnl} is intended to provide an environment for
numerical programming which combines the ease of use of packages like
Mathematica and MatLab with the speed of C and the elegance of C++.
It provides a C++ interface to the high-quality Fortran routines
made available in the public domain by numerical analysis researchers.

This release includes classes for
@itemize @bullet
@item Matrices and vectors.
The library is based on the old TargetJr/IUE
classes, which provide the standard operations without excessive overhead.

@item
Specialized classes for matrices and vectors with particular properties.
Class @code{vnl_diagonal_matrix} provides a fast and convenient diagonal
matrix, while fixed size matrices and vectors allow ``fast-as-C''
computations (see @code{vnl_matrix_fixed<T,n,m>} and example subclasses
@code{vnl_double_3x3} and @code{vnl_double_3}).

@item Matrix decompositions.
Classes @code{vnl_svd<T>}, @code{vnl_symmetric_eigensystem<T> },
@code{vnl_generalized_eigensystem}.

@item Real polynomials.
Class @code{vnl_real_polynomial} stores the coefficients
of a real polynomial, and provides methods of evaluation of the polynomial
at any @emph{x}, while class @code{vnl_rpoly_roots} provides a root finder.

@item Optimization.
Classes @code{vnl_levenberg_marquardt}, @code{vnl_amoeba},
@code{vnl_lbfgs}, @code{vnl_conjugate_gradient} allow optimization of
user-supplied functions either with @emph{or without} user-supplied
derivatives.

@item Standardized homes for commonly used functions and constants.
Class @code{vnl_math} defines constants (@code{pi}, @code{e}, @code{eps}...) and
simple functions (@code{sqr}, @code{abs}, @code{rnd}...).
To quote the header ``That's right, @code{M_PI} is nonstandard!''
Class @code{numeric_limits} is from the ISO standard document,
and provides a way to access basic limits of a type.  E.g.
@code{numeric_limits<short>::max()} returns the maximum value of a short.
@end itemize

Most routines are implemented as wrappers around the high-quality Fortran
routines which have been developed by the numerical analysis community over
the last forty years and placed in the public domain.  The central
repository for these programs is the ``netlib'' server
@url{http://www.netlib.org/}.  The National Institute
of Standards and Technology (NIST) provides an excellent search interface
to this repository in its Guide to Available Mathematical Software (GAMS)
at @url{http://gams.nist.gov}, both as a decision tree and a text search.

@subsubheading Compliance with the ANSI standard C++ library
@cindex valarray
The current draft of the ANSI standard (as at May 1996) includes classes
for 1-dimensional vectors (@code{valarray<T>}) and complex numbers (@code{
complex<T>}).  There is no standard for matrices.  The current vnl classes
are not implemented in terms of @code{valarray}, as there is a potential
perfomance hit, but in the future they might be.

@section Example: Basic matrix and vector operations

This section provides a brief tutorial in using the main components of vnl.
The main components which vnl supplies are the vector and matrix classes.
The basic linear algebra operations on matrices and vectors are fully
supported.  Some very brief examples follow, but for the most part the
usage of the @code{vnl_vector} and @code{vnl_matrix} classes is (we hope)
obvious and intuitive.

Using these is easy, and is often modelled on matlab.  For example, this
declares a 3x4 matrix of @code{double}:
@example
#include <vnl/vnl_matrix.h>
main() @{
  vnl_matrix<double> P(3,4);
@}
@end example
Operators are overloaded as expected, so if we have another 3x4
matrix @var{Q}, we can add the two like this
@example
vnl_matrix<double> R = P + Q;
@end example
The @code{vnl_vector} is equally straightforward.  Here we make a 4-element
vector of doubles, premultiply it by @var{P}, and print the result:
@example
vnl_vector<double> X(4);
cerr << P*X;
@end example
Several more examples are shown in Figure @ref{fig:matrixbasics}.

@cindex matrix indices, zero based
The vnl matrices are indexed from zero, as in C.  This is always a
difficult decision for C++ matrix libraries, as mathematical matrices use
indices starting from 1---the top left element of @var{A} is generally written 
@var{a_11}.  However, efficiently achieving this in C or C++ is a little
bit tricky, and can confuse some tools like Purify.  In the end, it was
decided that zero-based indexing was closer to being ``not weird''.

@figure
@cartouche
@smallexample
  vnl_matrix<double> A(3,3); // 3x3 matrix, elements not initialized
  vnl_matrix<double> B(3,3, 1.0); // 3x3 matrix, filled with ones.
  vnl_matrix<double> R(3,4); // Rectangular matrix
  cerr << "A is " << A.@ttb{rows}() << "x" << A.@ttb{columns}() << endl;
  cerr << "A has a total of " << A.@ttb{size}() << " elements" << endl;
  A(0,0) = 2.0; // Set top-left component of A.
  A(3,3) = 0.0; // *** Error, (3,3) is outside the range of A.
  A.@ttb{resize}(3,4); // Change size of A, invalidating elements.
  R.@ttb{update}(A, 0, 1); // Copy A into R, starting at (0,1): last 3 cols
  R.@ttb{set_column}(0, B.@ttb{get_column}(0)); // Copy 1st col of B into R
  cerr << R.@ttb{extract}(3,3, 0,1); // Print last 3 cols
  cerr << R.@ttb{get_n_columns}(1, 3) const; // Ditto

  A.@ttb{fill}(0.0); // Set all elements of A to 0.0
  A.@ttb{fill_diagonal}(1.0); // Set diagonal elements to 1.0
  A.@ttb{set_identity}(); // Set A to identity matrix
  R = R.@ttb{transpose}(); // Make transposed copy, assign to R
  R.@ttb{inplace_transpose}(); // Transpose R without copying.
  A.@ttb{flipud}(); // Reverse order of rows of A
  A.@ttb{fliplr}(); // Reverse columns
  A.@ttb{normalize_rows}();  // Divide each row by its 2-norm
  A.@ttb{scale_row}(0, 2.0); // Multiply row 0 by 2
  memset(A.@ttb{data_block}(), 0); // Access A's raw storage
  fill(A.@ttb{begin}(), A.@ttb{end}(), 0.0); // Fill using STL iterators

  vnl_matrix<double> C = B + 0.1 * A; // Arithmetic
  C @ttb{+=} 2.3;
  vnl_matrix<double> Csqrt = C.@ttb{apply}(sqrt); // Square root all elements
  @ttb{element_product}(Csqrt, Csqrt); // Should be equal to C, modulo roundoff

  cerr << A.@ttb{fro_norm}(); // Print sum of squares of elements
  cerr << A.@ttb{min_value}(); // Print minimum element

  if (A.@ttb{is_zero}(1e-8)) cerr << "Each element of A is within 1e-8 of zero\n";
  if (A.@ttb{is_identity}(1e-8)) cerr << "(A - I) is_zero to 1e-8\n";

  A.@ttb{read_ascii}(cin); // Read A from standard input

@end smallexample
@end cartouche
@caption{4.1}
Matrix basics.  A sample of the defined matrix operations.
@anchor{fig:matrixbasics}
@endcaption
@end figure


@subsection Efficiency: Fixed-size matrices and vectors.
A C programmer looking at the above examples will immediately grumble about
the inefficient memory allocation that is being performed.  Let's look into
the construction of @var{P} in more detail.  One can guess that the line
@example
vnl_matrix<double> P(3,4);
@end example
might result in a sequence of actions something like the following:
@example
struct vnl_matrix<double> P;
P.rows = 3;
P.columns = 4;
P.data = new double[P.rows * P.columns];
@end example
The expensive part of this operation is the call to @var{new}, which might
involve many instructions, and even a bit of operating system activity.
(Typically a call to @var{new} or @var{malloc} will cost about as much as a
2x2 matrix multiply).

If the matrices are small, as in these examples, this cost is
significant---if they're bigger than about 20x20 it is not so important.
Always remember, when thinking about efficiency, to consider what else is
going on in the program.  For example, if a matrix is being read from disk,
the time taken to read the matrix will be many times greater than a few
copies.  If you are about to do a matrix multiply (an O(n^3) operation
after all), an O(n^2) copy or an O(1) @var{new} are not going to be hugely
significant.

However, for small matrices we should try to avoid calls to @var{new}, and
vnl provides some fixed-size matrices and vectors which do so.  Thus a more
efficient version of the above sequence would be
@example
#include <vnl/vnl_matrix_fixed.h>
#include <vnl/vnl_vector_fixed.h>
main() @{
  vnl_matrix_fixed<double,3,4> P;
  vnl_vector_fixed<double,4> X;
  cerr << P*X;
@}
@end example
It's a bit clumsy typing these long names, so it is common to use
@code{typedef} to make shorter ones.  Indeed, a few are supplied with vnl,
for example @code{vnl_double_3x4}, so a more compact rendition of our
example is
@example
#include <vnl/vnl_double_3x4.h>
#include <vnl/vnl_double_4.h>
main() @{
  vnl_double_3x4 P;
  vnl_double_4 X;
  cerr << P*X;
@}
@end example
Note again that in this example there will be no noticeable speedup,
because 99% of the runtime will be spent on the last line, printing the
vector.

Because some operations such as multiplication have been specially coded
for the fixed-size classes, they are also made more efficient by knowing
the sizes in advance.  For example, this snippet
@example
vnl_double_3x3 R;               // Declare a 3x3 matrix 
vnl_double_3 x(1.0,2.0,3.0);    // Declare a 3-vector using local storage
vnl_double_3 rx = R * x;        // Multiply R by x and place the result in rx
@end example
is expanded by many compilers into an open-coded sequence of 9 multiplies
and 6 adds.  Note that as the fixed-size objects are subclasses of the
generic objects, all the same operations apply to them.  Only those which
have been specifically coded to do so enjoy the increase in speed.

@section Example: Matrix decomposition

The following fragment demonstrates use of the @code{vnl_svd<double>} class
to find the approximation of a 3x3 matrix @code{F} by the nearest matrix of
rank 2
@example
vnl_double_3x3 rank2_approximate(const vnl_double_3x3& F)
@{
  // Compute singular value decomposition of F
  vnl_svd<double> svd (F);
  // Set smallest singular value to 0
  svd.W(2,2) = 0;
  // Recompose vnl_svd<double> into UWV^T
  return vnl_double_3x3(svd.recompose());
@}
@end example

A more extensive example of the use of linear algebra is provided in
Figure 2, which contains a program to fit a hyperplane to
points read from standard input.

@figure
@cartouche
@example
#include <vnl/vnl_matops.h>
#include <vnl/algo/vnl_svd.h>
#include <vnl/algo/vnl_symmetric_eigensystem.h>

main() @{
  // Read points from stdin
  vnl_matrix<double> pts;
  cin >> pts;

  // Build design matrix D
  int npts = pts.rows();
  int dim = pts.columns();
  vnl_matrix<double> D(npts, dim+1);
  for(int i = 0; i < npts; ++i) @{
    for(int j = 0; j < dim; ++j)
      D(i,j) = pts(i,j);
    D(i,dim) = 1;
  @}

  // 1. Compute using vnl_svd<double>
  @{
    vnl_svd<double> svd(D);
    vnl_vector<double> a = svd.nullvector();
    cout << "vnl_svd<double> residual = " << (D * a).magnitude() << endl;
  @}

  // 2. Compute using eigensystem of D'*D
  @{
    vnl_symmetric_eigensystem<double>  eig(D.transpose() * D);
    vnl_vector<double> a = eig.get_eigenvector(0);
    cout << "Eig residual = " << (D * a).magnitude() << endl;
  @}
@}
@end example
@end cartouche
@caption{4.2}
Example of linear algebra operations. Points are read from stdin
into matrix @code{pts}, and a hyperplane fitted using two different methods.
@anchor{fig:planefit}
@endcaption
@end figure

@section Optimization
The package currently provides only for nonlinear least squares, rather
than general function minimization.  This means that the function to be
minimized must be the norm of a multivariate function.  However, this often
the case in vision problems, and allows us to use the powerful
Levenberg-Marquardt algorithm.  As an example of function minimization we
shall consider the ``notorious'' Rosenbrock function:
@example
f(x, y) = [ 10(y - x^2) ]
          [    1-x      ]
@end example
The graph of @math{f^2} is plotted below.

@image{rosenbrock,,1in}
@quotation
@anchor{fig:banana}
The Rosenbrock ``banana'' function, used as an optimization test
case.  Optimization starts on one side of the valley, and must find the
minimum around the corner.
@end quotation


We first derive a function object from @code{vnl_least_squares_function}.
The function object must initialize the base class with the number of
variables, and the number of residuals or unknowns.  In this case, both
domain and range are two dimensional.  The constructor must also supply a
@code{no_gradient} flag if the function @code{gradf} has not been
implemented.
@example
struct Rosenbrock : public vnl_least_squares_function @{
  Rosenbrock(): vnl_least_squares_function(2, 2, no_gradient) @{@}
@};
@end example

Then the abstract method @code{f} is implemented, which evaluates the
function.  Any data required for the evaluation can be stored in the class
and will be available whenever @code{f} is called.
@example
  double f(const vnl_vector<double>& x, vnl_vector<double>& fx) @{
    fx[0] = 10 * (x[1] - vnl_math_sqr(x[0]));
    fx[1] = 1 - x[0];
  @}
@end example
In order to perform the minimization, a @code{vnl_levenberg_marquardt} compute
object is constructed, passing the @code{vnl_least_squares_function}.
@example
Rosenbrock f;
vnl_levenberg_marquardt lm(f);
@end example
Having provided an initial estimate of the solution in vector @code{x}, the
minimization is performed:
@example
lm.minimize(x);
@end example
after which the vector @code{x} contains the minimizing parameters.

@section Design issues
This section documents some design decisions with which people might
disagree.  Please let me know how you feel on these issues.  It's also a
malleable to-do list.  The most important consideration has been to
provide simple lightweight interfaces that nevertheless allow for maximum
efficiency and flexibility.

@subsection Computation in constructors
@anchor{sec:computors}
As noted above, a common model in this package is that the compute objects
perform computation within the constructors.  While this is slightly
distasteful from a traditional C++ viewpoint, it offers a number of
advantages in both efficiency and ease of use.

The philosophical argument, say in the case of SVD, is that SVD is a noun.
The natural description is "The SVD of a matrix M" which is expressed in
C++ as @code{vnl_svd<double> svd(M) }.

Storage for the results of a computation is provided by the compute object
which is convenient, allowing client code to access only those results in
which it is interested.  Local storage is also more efficient, as objects
are constructed at the correct size, and initialized immediately.  In
contrast, passing empty objects to a function will generally involve a
resize operation, while returning a structure will incur a speed penalty
due to the necessary copy operations.

Namespace clutter is avoided in the @code{vnl_matrix} class.  While svd()
is a perfectly reasonable method for a matrix, there are many other
decompositions that might be of interest, and adding them all would make
for a very large matrix class, even though many methods might not be of
general interest.

The model extends readily to @math{n}-ary operations such as generalized
eigensystems, which combine two objects to produce others.  Such operations
cannot be methods on just one matrix.

@subsection Fixed-size classes
The classes which provide for fast fixed-size matrices and vectors are
essential in a system which wants to make claims for efficiency.  In
addition, a great many uses of these objects @emph{do} know the size in
advance.  In this case code using say @code{vnl_double_3} is more efficient (as
well as more self-documenting) than the equivalent referring to a
@code{vnl_vector} of unknown size.

@subsection Transposing for Fortran
In calling Fortran code, the first difficulty that becomes apparent is that
Fortran arrays are stored column-wise, while traditional `C' arrays are
stored rowwise -- a trend that is followed by the @code{vnl_matrix} class.
One solution is simply to store C++ arrays columnwise, and this was an
early plan for the IUE.

I have not done anything to alleviate this for two reasons -- most routines
we call are expensive enough (i.e. @math{O(n^3)}) that the @math{O(n^2)} copy
operation is only a small performance hit.  Secondly, many decompositions
satisfy a transpose-equivalence relationship.  For example suppose we wish
to use a Fortran matrix multiply which has been hand-optimized for some
particular machine.  Such a routine may be declared
@example
mmul(A, B, C) // Computes C = A B, fortran storage
@end example
To use this with row-stored arrays, we recall the simple identity
@example
C = (C')' = (B' A')' = AB
@end example
and therefore call @code{mmul(B, A, C)}, reversing the order of parameters
@math{A} and @math{B}.  The fortran code will lay down the result of
@math{B' A'} into the columns of @math{C}, thereby computing @math{C' =
B' A'} from the point of view of the caller.

This however, doesn't apply to the vnl_svd<double>, as algorithms generally require only the
``economy-size'' version where size(U) = size(M) in @math{U S V' = M}.  This
is @math{O(mn^2)} flops rather than @math{O(m^2n)} for the fullsize one.  Using the
transpose-equivalence would mean a doubling of the computation time, as the
``economy-size'' decomposition is only implemented for @math{m > n}.  If someone
does need the full size decomposition, a flag could be added or a new @code{vnl_svd}
class written.

@c 
@c @c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@c 
@c @section Basics
@c @inputclass{math}
@c @c @page
@c 
@c @inputclass{matrix}
@c @inputclass{vnl_matrix_ref}
@c @c @page
@c 
@c @inputclass{vector}
@c @inputclass{vnl_vector_ref}
@c @c @page
@c 
@c @inputclass{numeric_limits}
@c @inputclass{vnl_linear_operators_3}
@c @c @page
@c 
@c @c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@c @section Specialized Matrices
@c @inputclass{vnl_diag_matrix}
@c @c @page
@c 
@c @inputclass{vnl_matrix_fixed_ref}
@c @c @page
@c @inputclass{vnl_matrix_fixed}
@c @inputclass{vnl_double_3x3}
@c @c @page
@c @inputclass{vnl_vector_fixed}
@c @inputclass{vnl_vector_ref}
@c @inputclass{vnl_double_2}
@c @inputclass{vnl_double_3}
@c @inputclass{vnl_double_4}
@c @c @page
@c 
@c 
@c @c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@c @section Matrix decompositions
@c @inputclass{vnl_svd<double>}
@c @inputclass{vnl_svd}
@c @c @page
@c 
@c @inputclass{vnl_symmetric_eigensystem<double> }
@c @inputclass{vnl_generalized_eigensystem}
@c @c @page
@c 
@c @c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@c @section Function minimizatio
@c @inputclass{vnl_least_squares_function}
@c @c @page
@c 
@c @inputclass{vnl_levenberg_marquardt}
@c @c @page
@c 
@c 
@c @c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@c @section Real polynomials
@c @inputclass{vnl_real_polynomial}
@c @inputclass{vnl_rpoly_roots}
@c @c @page
@c 
@c 
@c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@section Future work
Many of the existing methods are unimplemented, or could benefit from
optimization.  Users can contribute code to address these deficiencies
based on the existing examples, and using the conversion hints in
Appendix~A.  In addition there are many algorithms that ought to be
included, listed roughly in order of priority:
@itemize

@item
Additional matrix decompositions in the same vein, including an updateable
QR, a basic LU, etc.

@item Choice of backend functions---for optimization one might prefer Powell,
or even simulated annealing.  For matrix decompositions, particular users
might prefer to interface to NAG or IMSL routines.  These choices must be
allowed to be made easily, thereby encouraging the comparison of algorithms
and of alternative implementations.

@item Many classes are defined as double-only rather than templated.
I will use default template arguments when the compilers support them.
@end itemize

@comment ------------------------------------------------------------------
@node    vil,       vgl,     vnl,      top
@comment node-name, next,    previous, up
@chapter vil: Imaging
@cindex vil
@cindex Images

@chapsummary
Load images using @code{vil_load}. Access them
 using a @code{vil_memory_image_of<T>}.
@endchapsummary


The @vxl{} image library is an evolutionary rewrite of the TargetJr Image
library.  As with its predecessor, its primary goal is to provide flexible
and powerful access to all 2D images, including those too large to fit in
the address space of a single program or process.  This goal must be
achieved, however, without affecting the speed or complexity of
the much more common case of programs which can read all their images into
main memory and process them in-core.  In fact, both cases need similar
treatment: even in-core images are assumed to be sufficiently large (say a
megabyte) that special care must be taken to avoid unnecessary copying of
their data.  In both cases, the normal requirements of efficiency and
ease-of-use apply.  The system must allow:
@itemize @bullet
@item Fast access to images on disk, at no more than a 10% speed penalty
for operations on images in memory.

@item Fast loading of subsets of the image data.  To look at a
small portion of a 10000 by 10000 pixel satellite image, one should
not have to load the entire 300 megabytes into memory.

@item Efficient access to the native image layout.  Some systems convert
all images to a consistent internal format when loading, for example, RGB
top-to-bottom.  This is convenient for users, and is what vil's
@code{vil_load_rgb} function does.  However, for some applications, the
disk format is specially designed for efficiency, so it must also be
possible to get raw access to the disk format.

@item Efficient memory management, both automatic and programmer-mediated.
Automatic management is vital during program development, when the code is
changing quickly.  On the other hand, release builds need the kind of
optimizations that only a human can apply.
@end itemize

@section Loading and saving
Let's look at an example of vil in use.  This program makes an image from a
disk file, copies it into memory, and prints the pixel at
100,100.

@example
#include <vcl/vcl_iostream.h>
#include <vil/vil_load.h>
#include <vil/vil_memory_image_of.h>

int main()
@{
  vil_image img = vil_load("foo.ppm");
  vil_memory_image_of<unsigned char> buf(img);
  vcl_cerr << "Pixel 100,100 = " << buf(100,100) << endl;
@}
@end example

Let's go through the program line by line@footnote{This program was more
difficult to debug than it looks, because the test image used happened to
have the value 255 at pixel 100,100.  Of course, 255 is an unlikely value
for a pixel (as is 12, but that's not such a round number), so one
immediately assumes there's a bug somewhere.  There wasn't.}, and see in
detail what is happening.  The first interesting line is this call to
@code{vil_load}
@example
  vil_image img = vil_load("foo.ppm");
@end example
The load function opens the file given to it, "foo.pgm" here, and examines
its contents to determine what kind of image it is.  Then it makes a
@code{vil_image} object which holds the open file, and remembers details
like the image size.  It doesn't read the image yet, but it remembers
enough to later read any rectangular section of the image.  This object is
returned and assigned to the variable @var{img}. Image objects such as
@var{img} behave like @emph{smart pointers}---they can be copied around
easily and cheaply, because they always point to the same image.

@cindex file, reading from
In this case we're not going to bother about handling large images, so the
next line reads the whole lot into a memory buffer:
@example
  vil_memory_image_of<unsigned char> buf(img);
@end example
This creates a 2D array of the same size as @var{img}, and reads the image
data from disk into it.  We can now easily access the data using the
overloaded parenthesis operator, and print out the value.
@example
  cerr << "Pixel 100,100 = " << buf(100,100) << endl;
@end example
Memory images are derived classes of vil_image, and they too can be passed
around cheaply, always referring to the same block of pixels.  To copy a
memory image, use @xref{sec:vil_copy}.

@subsection Loading and saving: The threshold program
@cindex threshold example
@cindex vil_save
Anyway, the usual next step in demonstrating an image handling library is
to show thresholding, so let's have a look.  This program loads an image
into memory, and creates a new image where all pixels greater than a
threshold value are set to 255.
@example
#include <vil/vil_load.h>
#include <vil/vil_memory_image_of.h>

int main()
@{
  vil_image img = vil_load("foo.ppm");

  vil_memory_image_of<unsigned char> buf(img);

  for(int y = 0; y < buf.height(); ++y)
    for(int x = 0; x < buf.width(); ++x)
      if (buf(x,y) < 200)
	buf(x,y) = 0;

  vil_save(buf, "foothresh.ppm");
@}
@end example
The call to @code{vil_save} sends the modified image in @var{buf} to disk.
The choice of file format is determined automatically from the extension of
the filename.  In this case, the extension is "pgm", the Portable Gray Map
format.  If one wants more control, a string can be appended to specify the
format, e.g.
@cindex vil_save, choosing a specific file format
@example
  vil_save(buf, "foothresh.ppm", "jpeg");
@end example
Of course, it's rarely sensible to have incompatible names and formats, but
the user of your program may have chosen the name, so that you have no
other option.

@subsection Handling different pixel formats

The programs given so far are a bit limited in that they can only operate
on greyscale images.  If you give a colour image to the @emph{threshold}
program, it will terminate suddenly when it tries to copy the 24-bit RGB
image into an 8bpp (bits per pixel) buffer.  One way to handle multiple
formats is to choose the most general format one is likely to encounter and
convert all images to it.  In the examples above, a
pretty safe choice is to convert all images to 24-bit RGB at load time.
The colour threshold program looks like this:
@example
#include <vil/vil_load.h>
#include <vil/vil_memory_image_of.h>
#include <vil/vil_rgb_byte.h>

int main()
@{
  vil_image img = vil_load_rgb("foo.ppm");

  vil_memory_image_of<vil_rgb_byte> buf(img);

  for(int y = 0; y < buf.height(); ++y)
    for(int x = 0; x < buf.width(); ++x)
      if (buf(x,y).R < 200 && buf(x,y).G < 200 && buf(x,y).B < 200)
        buf(x,y) = vil_rgb_byte(0,0,0);

  vil_save(buf, "foothresh.ppm");
@}
@end example
@cindex vil_load_rgb
This code introduces @code{vil_load_rgb}, which forces any format it is
given into RGB.  It also uses the @code{vil_rgb_byte} class, which is a
simple way to handle RGB triples.

@section Creating images from scratch
@cindex images, creating
Sometimes one would like to write a program which creates images, rather
than modifying an existing one.  Of course, the programs above do this,
because a @code{vil_memory_image_of<T>} is indeed a @code{vil_image}.
An example where one creates a completely new image is in generating an
image of constant value, perhaps to use as a background, or test image.  This
program creates a 256x256 image filled with the value 128.
@example
#include <vil/vil_load.h>
#include <vil/vil_memory_image_of.h>

int main()
@{
  vil_memory_image_of<unsigned char> buf(256, 256);

  buf.fill(128);

  vil_save(buf, "foothresh.ppm");
@}
@end example

@section Copying an image
@anchor{sec:vil_copy}
@cindex images, copying
You should know by know that copying @code{vil_image} objects does not
duplicate the data they point to.  This allows images to be passed into and
out of functions efficiently.  It also means that modifying the data in one
vil_image might change that in another.  Take this example
@example
...
vil_memory_image_of<float> a = vil_load("x");
vil_memory_image_of<float> b = a;
b(100,100) = 12;
...
@end example
After the assignment in line 3, both @var{a(100,100)} and @var{b(100,100)}
are set to the value 12.  On the other hand, if we had used
@code{vil_copy}, thus:
@example
...
vil_memory_image_of<float> a = vil_load("x");
vil_memory_image_of<float> b = vil_copy(a);
b(100,100) = 12;
...
@end example
then @var{a} is unchanged after the assignment to @var{b(100,100)}.
Note again that the actual copying is done in @code{vil_copy}; when the
return value is assigned to @var{b}, there is an efficient pointer copy.

@section Dealing with large images

Most users of @vxl{} deal with small images, which it is sensible to copy
into a @code{vil_memory_image} before operating on them.  If you are like
most users, or if this is your first time through the book, you may skip
the rest of this chapter.  If you are like many programmers, however, you
might like to know what vil is like under the hood.

When a very large image does have to be analysed, it is generally faster to
allow the image to remain on disk, and only load sections when needed (for
example, when displayed on the screen).  Because it is computationally
cheap to support this usage, vil does so.  To understand how large images
are handled, we look again at the @code{vil_image} class.

@subsection The image class: @code{vil_image}
@cindex image layout
@cindex planes
@cindex components
@cindex image, width and height

The heart of the imaging library is the class @code{vil_image}, which
contains a handle to an image, which may be in memory, or on disk.  Most
image-handling code in @vxl{} operates on blocks of the image, so that
large images can be processed efficiently.  As in TargetJr, the key
operations on a @code{vil_image} are the block read and write operations:
@smallexample
   i.get_section(buffer, rect_x0, rect_y0, rect_width, rect_height);
   i.put_section(buffer, rect_x0, rect_y0, rect_width, rect_height);
@end smallexample
The @code{get_section} method copies pixels from the image to the
user-supplied memory in @code{buffer}, which must be pre-initialized to
the appropriate size.

@subsection Example: Printing a pixel from a greylevel image
Without much more explanation, here is the vil code to print the value at
pixel location (100,200).  It assumes blithely that the file "theimage.pgm"
exists, is readable, and contains a grey image whose size is at least 100
by 200 pixels:
@smallexample
main()
@{
   vil_image img = vil_load("theimage.pgm");
   vil_byte value; // buffer into which value will be read
   img.get_section(&value, 100, 200, 1, 1);
   cerr << "val(100,200) = " << int(value) << endl;
@}
@end smallexample

@subsection Image layout
The vil image is a 2D array of pixels.  Pixels come in many guises and
sizes: integers, floating point numbers, tuples of numbers such as RGB.
It is important in VIL to know about layout, meaning the order in which the
numbers are laid out in memory or on the disk.  The obvious order for an
image which corresponds to a video signal is left-to-right, top-to-bottom;
however not all images are video signals, and many alternatives are
common.  Some of these types of alternative are handled explicitly by
vil, most others can be handled easily using vil's extension facilities.

@figure
@cartouche
@example


   vil_image      -- contains_a -->    vil_image_impl
    |                                   |
    +vil_memory_image                   +vil_memory_image_impl
    | |                                 |
    | +vil_memory_image_of<T>           +vil_pnm_image_impl
    |                                   |
    +vil_file_image                     ... etc


@end example
@end cartouche
@caption{4}
The parallel @code{vil_image} and @code{vil_image_impl} class hierarchies.
@endcaption
@end figure

@ejectallfigures

@comment ------------------------------------------------------------------
@node    vgl,         vgui,    vil,      top
@comment node-name,   next,    previous, up
@chapter vgl: Geometry
@cindex vgl
@cindex Geometry

@chapsummary
Geometric entities, like points and lines, should be kept
simple.
@endchapsummary

@comment ------------------------------------------------------------------
@node    vgui,      Conclusion,     vgl,      top
@comment node-name, next,    previous, up
@chapter vgui: cross-platform user interface
@cindex vgui
@cindex OpenGL
@cindex graphical user interface


@comment ------------------------------------------------------------------
@node    Conclusion,  ,    vgui,      top
@comment node-name, next,    previous, up
@chapter Conclusion


@comment ------------------------------------------------------------------
@appendix  Filenames and structure
The directory structure of VXL is below
@example
  $VXLROOT/vxl/vcl
              /vnl
              /vbl
              /vil
              /config.$BUILD
          /config
          /Scripts
@end example
The last two directories are part of the IUE/TargetJr makefiles so are
not needed by those using Visual Studio or their own build systems.

@c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@appendix Adding to vnl_algo
The strategy adopted for converting and wrapping the fortran files is a
little involved.  Some routines are simple to do, others very tricky.  The
general procedure is as follows.  These steps are elaborated upon in the
example below.
@section Overview
@enumerate
@item Use GAMS to find the module name, in SLATEC if possible, although
CMLIB and TOMS routines are also public domain and good.

@item Convert the fortran to C using f2c

@item Add the routine to the Imakefile in the netlib library.

@item Encapsulate the routine in a class in Numerics, after determining a
suitable interface.

@item Read the module documentation and determine the calling sequence.

@item In the calling method, create all necessary workspace arrays and
temporary variables that the call requires, call the external routine, and
convert the results into the classes that VXL expects.

@item After the call, interpret the error code, and handle accordingly.
@end enumerate

@section Problems
There are a few potential sources of difficulty, mostly in item 5, but in
general I find that gritting one's teeth and guessing is a surprisingly good
strategy.  The main points to remember are:
@itemize
@item All scalar variables are passed by reference.  This means that you
need to store all constants in variables and pass their addresses or
declare the routines as accepting references.  I do the latter for input
variables, and the former for outputs.

@item Fortran arrays start from 1 rather than 0.  This is actually a
non-problem, as f2c generates code which interfaces zero-based to one-based
arrays using the Numerical Recipes trick of decrementing the pointer, but
is mentioned here for the benefit of fortran programmers.

@item Fortran arrays are stored column-wise rather than row-wise.  Class
@code{vnl_fortran_copy} provides an easy and efficient way to transpose
matrices before calling.
@end itemize

In addition to these fortran specifics, it is important to be aware of the
sorts of design patterns seen in numerical code.  Many routines are coded
for maximum generality and efficiency, which can make reading the
descriptions heavy going.  Common conventions are:
@itemize
@item An array is passed with three dimensions: number of rows in the physical
array, number of rows to use for computation and number of columns.  This
allows the routines to be used on any submatrix of a larger matrix.

@item Output results overwrite the input matrix.

@item Output results are stored in some compact form, which must be decoded
before use.  Note however that in many cases routines are supplied to
perform further computations using the encoded representation for time and
space efficiency.  The new QR class will demonstrate how to take advantage
of this.

@item The results of pivoting are generally returned in vectors of
integers (say @code{ipvt}), where @code{ipvt[i]} is the position to which
row/column @code{i} has been moved. These permutations which must be
applied to the results in order to complete the process.
@end itemize

@section Example conversion -- QR decomposition
Given the need for an algorithm that is not yet included in the Numerics
package, say a routine to compute the QR decomposition, your first stop is
the GAMS decision tree.  Class ``D'' is Linear Algebra, and class ``D5'' is
QR decomposition.  The SLATEC implementation is called DQRDC (Double
precision QR DeComposition).  Download the source, or obtain it from a
local SLATEC distribution.  Convert it to a C source file and a prototype
file using
@example
   f2c -P dqrdc.f
@end example
and from the prototype file @code{dqrdc.P} we find that the function
prototype is
@example
   int dqrdc_(doublereal *x, integer *ldx, integer *n, integer *p,
              doublereal *qraux, integer *jpvt, doublereal *work,
              integer *job);
@end example

At this point, the header of the fortran file @code{dqrdc.f} is examined in
order to determine the meaning of the parameters.  Considering parameter
@code{X}, we find
@example
   X     DOUBLE PRECISION(LDX,P), where LDX .GE. N.
         X contains the matrix whose decomposition is to be computed.
@end example
This means that X is a LDX row by P column matrix, and that we require a
decomposition of the first N rows.  This is a common convention in fortran
programs which allows computation on subblocks of matrices.  In general, we
will assume that we wish to work on the full matrix, and therefore that LDX
= N.  To create the required transformed copy of the matrix, use class
@code{vnl_fortran_copy}:
@example
   vnl_fortran_copy Xtranspose(X);
@end example
Now, the function may be called as
@example
   int n = X.rows();
   int p = X.columns();
   vnl_vector<int> jpvt(p);
   jpvt.fill(0); // Mark all columns as pivotable
   vnl_vector<double> work(p);
   int do_pivoting = 1;
   vnl_vector<double> qraux(p);
   dqrdc_(Xtranspose, &n, &n, &p,
          qraux.data_block(), jpvt.data_block(), w.data_block(),
          &do_pivoting);
@end example


@comment ------------------------------------------------------------------
@node    Concept Index,     , , Top
@c        node-name,    next, previous,        up
@unnumbered Concept Index

@printindex cp

@bye

