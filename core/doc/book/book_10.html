<HTML>
<HEAD>
<TITLE>VXL: B. Adding to vnl_algo</TITLE>

<META NAME="description" CONTENT="VXL: B. Adding to vnl_algo">
<META NAME="keywords" CONTENT="VXL: B. Adding to vnl_algo">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html @T2H_VERSION@">

</HEAD>

<BODY LANG="" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC52"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book_9.html#SEC51"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book_11.html#SEC56"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book_11.html#SEC56">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>

<HR SIZE=2>
<H1> B. Adding to vnl_algo </H1>
<!--docid::SEC52::-->
The strategy adopted for converting and wrapping the fortran files is a
little involved.  Some routines are simple to do, others very tricky.  The
general procedure is as follows.  These steps are elaborated upon in the
example below.
<HR SIZE="6">
<A NAME="SEC53"></A>
<H2> B.1 Overview </H2>
<!--docid::SEC53::-->
<OL>
<LI>Use GAMS to find the module name, in SLATEC if possible, although
CMLIB and TOMS routines are also public domain and good.
<P>

<LI>Convert the fortran to C using f2c
<P>

<LI>Add the routine to the Imakefile in the netlib library.
<P>

<LI>Encapsulate the routine in a class in Numerics, after determining a
suitable interface.
<P>

<LI>Read the module documentation and determine the calling sequence.
<P>

<LI>In the calling method, create all necessary workspace arrays and
temporary variables that the call requires, call the external routine, and
convert the results into the classes that VXL expects.
<P>

<LI>After the call, interpret the error code, and handle accordingly.
</OL>
<P>

<HR SIZE="6">
<A NAME="SEC54"></A>
<H2> B.2 Problems </H2>
<!--docid::SEC54::-->
There are a few potential sources of difficulty, mostly in item 5, but in
general I find that gritting one's teeth and guessing is a surprisingly good
strategy.  The main points to remember are:
<UL>
<LI>All scalar variables are passed by reference.  This means that you
need to store all constants in variables and pass their addresses or
declare the routines as accepting references.  I do the latter for input
variables, and the former for outputs.
<P>

<LI>Fortran arrays start from 1 rather than 0.  This is actually a
non-problem, as f2c generates code which interfaces zero-based to one-based
arrays using the Numerical Recipes trick of decrementing the pointer, but
is mentioned here for the benefit of fortran programmers.
<P>

<LI>Fortran arrays are stored column-wise rather than row-wise.  Class
<CODE>vnl_fortran_copy</CODE> provides an easy and efficient way to transpose
matrices before calling.
</UL>
<P>

In addition to these fortran specifics, it is important to be aware of the
sorts of design patterns seen in numerical code.  Many routines are coded
for maximum generality and efficiency, which can make reading the
descriptions heavy going.  Common conventions are:
<UL>
<LI>An array is passed with three dimensions: number of rows in the physical
array, number of rows to use for computation and number of columns.  This
allows the routines to be used on any submatrix of a larger matrix.
<P>

<LI>Output results overwrite the input matrix.
<P>

<LI>Output results are stored in some compact form, which must be decoded
before use.  Note however that in many cases routines are supplied to
perform further computations using the encoded representation for time and
space efficiency.  The new QR class will demonstrate how to take advantage
of this.
<P>

<LI>The results of pivoting are generally returned in vectors of
integers (say <CODE>ipvt</CODE>), where <CODE>ipvt[i]</CODE> is the position to which
row/column <CODE>i</CODE> has been moved. These permutations which must be
applied to the results in order to complete the process.
</UL>
<P>

<HR SIZE="6">
<A NAME="SEC55"></A>
<H2> B.3 Example conversion -- QR decomposition </H2>
<!--docid::SEC55::-->
Given the need for an algorithm that is not yet included in the Numerics
package, say a routine to compute the QR decomposition, your first stop is
the GAMS decision tree.  Class "D" is Linear Algebra, and class "D5" is
QR decomposition.  The SLATEC implementation is called DQRDC (Double
precision QR DeComposition).  Download the source, or obtain it from a
local SLATEC distribution.  Convert it to a C source file and a prototype
file using
<TABLE><tr><td>&nbsp;</td><td class=example><pre>   f2c -P dqrdc.f
</pre></td></tr></table>and from the prototype file <CODE>dqrdc.P</CODE> we find that the function
prototype is
<TABLE><tr><td>&nbsp;</td><td class=example><pre>   int dqrdc_(doublereal *x, integer *ldx, integer *n, integer *p,
              doublereal *qraux, integer *jpvt, doublereal *work,
              integer *job);
</pre></td></tr></table><P>

At this point, the header of the fortran file <CODE>dqrdc.f</CODE> is examined in
order to determine the meaning of the parameters.  Considering parameter
<CODE>X</CODE>, we find
<TABLE><tr><td>&nbsp;</td><td class=example><pre>   X     DOUBLE PRECISION(LDX,P), where LDX .GE. N.
         X contains the matrix whose decomposition is to be computed.
</pre></td></tr></table>This means that X is a LDX row by P column matrix, and that we require a
decomposition of the first N rows.  This is a common convention in fortran
programs which allows computation on subblocks of matrices.  In general, we
will assume that we wish to work on the full matrix, and therefore that LDX
= N.  To create the required transformed copy of the matrix, use class
<CODE>vnl_fortran_copy</CODE>:
<TABLE><tr><td>&nbsp;</td><td class=example><pre>   vnl_fortran_copy Xtranspose(X);
</pre></td></tr></table>Now, the function may be called as
<TABLE><tr><td>&nbsp;</td><td class=example><pre>   int n = X.rows();
   int p = X.columns();
   vnl_vector&#60;int&#62; jpvt(p);
   jpvt.fill(0); // Mark all columns as pivotable
   vnl_vector&#60;double&#62; work(p);
   int do_pivoting = 1;
   vnl_vector&#60;double&#62; qraux(p);
   dqrdc_(Xtranspose, &#38;n, &#38;n, &#38;p,
          qraux.data_block(), jpvt.data_block(), w.data_block(),
          &#38;do_pivoting);
</pre></td></tr></table></P><P>

<A NAME="Concept Index"></A>
<HR SIZE="6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[ &lt;&lt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[ &gt;&gt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book_11.html#SEC56">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
</BODY>
</HTML>
