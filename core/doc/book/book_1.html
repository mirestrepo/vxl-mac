<HTML>
<HEAD>
<TITLE>VXL: Introduction</TITLE>

<META NAME="description" CONTENT="VXL: Introduction">
<META NAME="keywords" CONTENT="VXL: Introduction">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html @T2H_VERSION@">

</HEAD>

<BODY LANG="" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC1"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[ &lt;&lt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book_3.html#SEC18"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book_11.html#SEC56">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>

<HR SIZE=2>
<A NAME="Introduction"></A>
<H1> 1. Introduction </H1>
<!--docid::SEC1::-->
<P>

<BLOCKQUOTE>
<STRONG>Chapter summary</STRONG>:<BR>
 VXL is efficient, simple, and fun to use.
</BLOCKQUOTE>
<P>

This document describes v<EM>x</EM>l, a collection of C++ libraries designed for
computer vision research.  Because it's for computer vision it needs to be
<EM>efficient</EM>, handling large quantities of numerical data with little
overhead.  Because it's for research it must be <EM>portable</EM>, so that
one can write and run one's program on any machine available, for example
in order to access a special camera or fast image processing hardware.
</P><P>

The v<EM>x</EM>l collection's portability and efficiency are traits which are due
in large part to its parentage.  The package was built by extracting the
core functionalities of two large systems: the "Image Understanding
Environment" (IUE) and "Target junior" (TargetJr).  Although these
environments contained a wealth of useful code, and have facilitated much
research, they are widely known for their bulk, and the difficulty of
learning to use them.  Common complaints have been
<UL>
<LI>
"Too heavy": To use even one small routine, a large portion of the
environment must be included in the user's program, increasing program
size, compile time, and startup time.  Sometimes the increase is such that
debuggers and other tools fail to work.
<LI>
"Too slow": In some cases, the design of the earlier systems restricted
the efficiency of code that could be written when using them.  This was in
some part due to deficiencies of the C++ compilers in use, but also due to
the use of since-superseded programming paradigms.
<LI>
"Too weird": Because the IUE is a large system, intended to be used as a
programming environment, it imposes stylistic quirks on programmers who use
it.  The most apparent of these was the use of LaTeX to generate code,
which offered many benefits, but was ultimately rejected by users.
</UL>
Despite these complaints, the quality of the software available in the
environments, and the promise of a sustained, concerted software
development effort has meant that the IUE/TargetJr has many users
worldwide.  The job of v<EM>x</EM>l is to make that many <EM>happy</EM> users, by
creating a set of libraries which have the same useful code, but which are
light, fast, and not weird.
<P>

<HR SIZE="6">
<A NAME="SEC2"></A>
<H2> 1.1 Contents </H2>
<!--docid::SEC2::-->
<P>

The core of v<EM>x</EM>l was defined in Feburary 2000, and comprises five
libraries.
</P><P>

<HR SIZE="6">
<A NAME="SEC3"></A>
<H3> 1.1.1 vcl: The C++ compatibility layer. </H3>
<!--docid::SEC3::-->
<P>

The job of vcl is to turn your compiler into a standard C++ compiler.  In
particular, it ensures that your standard library behaves at least
something like that defined in the ANSI/ISO standard.  In an ideal world,
vcl would not be necessary, as all compiler vendors would ship perfectly
compliant systems.  But then, in a perfect world, C++ wouldn't be the only
choice for high efficiency high-level programming.
</P><P>

<HR SIZE="6">
<A NAME="SEC4"></A>
<H3> 1.1.2 vbl: Basics. </H3>
<!--docid::SEC4::-->
The basics library contains a small set of generally useful C++ classes and
functions, notably smart pointers, file and directory handling,
command-line argument parser, string utilities, a timer, etc.
<P>

<HR SIZE="6">
<A NAME="SEC5"></A>
<H3> 1.1.3 vnl: Numerical algorithms. </H3>
<!--docid::SEC5::-->
The main classes in vnl are the matrix and vector classes, which are very
simple c-like objects.  There is no reference counting, objects are
returned by value, or passed into routines.  The use of objects to hold the
output of matrix decompositions also reduces the amount of copying that
needs to be done.  The numerical algorithms are wrappers around
public-domain, high quality Fortran code from the TargetJr <CODE>netlib</CODE>
library.
<P>

<HR SIZE="6">
<A NAME="SEC6"></A>
<H3> 1.1.4 vil: Imaging. </H3>
<!--docid::SEC6::-->
The imaging library is designed to work well with very large images, but
its primary design objective is to be fast and convenient for the typical
in-core images that are encountered in video and digital image processing.
A panoply of file formats is handled, and it is easy to add support for a
new format.
<P>

<HR SIZE="6">
<A NAME="SEC7"></A>
<H3> 1.1.5 vgl: Geometry. </H3>
<!--docid::SEC7::-->
It is in geometry that the spartan aesthetic of the core of v<EM>x</EM>l becomes
most apparent.  The library deals with the geometry of points, curves, and
other objects in 2 or more dimensions, but may not call on the numerics
library.  Therefore, it is  restricted to operations which it is reaonable
to express in standard C++, which places a useful limit on what may be
placed there.  For example, surface fitting cannot be in geometry as it
would require the singular value decomposition.  However, there is much
here that is useful, and the library is quite large enough already.  The
<CODE>vgl_algo</CODE> library contains the higher-level code.
<P>

<HR SIZE="6">
<A NAME="SEC8"></A>
<H2> 1.2 Documentation </H2>
<!--docid::SEC8::-->
The v<EM>x</EM>l documentation comes in two main forms: this book, and structured
comments in the source code, which are automatically extracted.  The book
is intended to be a single reference, where all the high-level
documentation resides.   In TargetJr and the IUE there was always a problem
finding documentation, as it was in too many places.  In v<EM>x</EM>l, we are
following the practice of some other successful systems such as vtk, and
providing one monolithic document with, we hope, a good index.
<P>

<HR SIZE="6">
<A NAME="SEC9"></A>
<H3> 1.2.1 The VXL Book </H3>
<!--docid::SEC9::-->
<P>

The book (in subdirectory book) is a human-written collection of VXL
documentation, suitable for printing.  It is intended to be readable as an
introduction to the various facilities provided by the v<EM>x</EM>l libraries,
and the be browsable as a first source of examples and tips.
</P><P>

<A NAME="SEC10"></A>
<H4> Why texinfo? </H4>
<!--docid::SEC10::-->
It is written in texinfo, a limited form of LaTeX which allows us to make
various forms of output: printed, HTML, windows help files, emacs info, and
plain text files.  Each of these forms has its adherents, and each is
useful.  There are other documentation systems which allow multiple output
formats, but none match texinfo in the three main formats: paper,
hypertext, and ASCII.  This is because it's difficult to target such
disparate formats, and texinfo has evolved over many years to do it well.
<P>

On the other hand, texinfo is hard to learn for those who don't know TeX
or LaTeX, so we are keeping an eye on formats such as <EM>DocBook</EM>.
</P><P>

<HR SIZE="6">
<A NAME="SEC11"></A>
<H3> 1.2.2 Automatically generated documentation </H3>
<!--docid::SEC11::-->
<P>

Although the human-written v<EM>x</EM>l book is the first source, the definitive
authority on what a class or function does must be the source code
comments.  The book will give a high-level description of the most
important and commonly-used features of a class, but the source code
contains the details.  In order to make these details easier to scan, the
v<EM>x</EM>l source files contain specially structured comments, which can be
scanned by the <EM>Doxygen</EM> program and converted into an attractive
hyperlinked reference.
</P><P>

An example of what the syntax for documentation looks like can be found
in <CODE>vxl/doc/vxl_doc_rules.[h,cxx]</CODE>, but briefly a comment line which
begins with <CODE>//:</CODE> is documentation for the type, function, or
variable which follows it.  For example
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>//: Brief description of my_class
class my_class {
  //: \brief Brief description, the long one is in the .cxx file
  my_class();
};
</FONT></pre></td></tr></table></P><P>

<HR SIZE="6">
<A NAME="SEC12"></A>
<H2> 1.3 The Design and Evolution of v<EM>x</EM>l </H2>
<!--docid::SEC12::-->
<P>

Design goals:
</P><P>

<UL>
<LI>Cross platform
<P>

<LI>Loosely coupled
<P>

<LI>light weight -- simple interfaces
<P>

<LI>high-powered -- allow infinitely large images.
<P>

<LI>uniform naming -- of course.
</UL>
<P>

<HR SIZE="6">
<A NAME="SEC13"></A>
<H3> 1.3.1 Motivation </H3>
<!--docid::SEC13::-->
In OpenGL, you guess the name of something, and you're generally
right.  This is what we would like to achieve with v<EM>x</EM>l.
<P>

<A NAME="IDX1"></A>
Simple and free of programming dogma.  For example, many v<EM>x</EM>l routines
exist as C-like functions.  For some tasks, C-like
functions are more appropriate than a forced object-orientation, for others
objects are clearly the more intuitive and compact representation.  This is
clearly seen in the imaging library, where the <CODE>vil_image</CODE> object is
passed to and returned from C-like functions, for example
<TABLE><tr><td>&nbsp;</td><td class=example><pre>  vil_image i = vil_load(filename);
  i = vil_smooth_gaussian(i, 0.6);
  vil_save(i, out_filename, "pnm");
</pre></td></tr></table>In this case, object orientation ensures that memory is managed
efficiently, without unnecessary copying of data, while using functions
makes the code more readable.
</P><P>

When building a large system, it is crucial to maintain consistent
conventions for file-system structure, and identifier naming.  However, a
crucial philosophy in the design of v<EM>x</EM>l is that system conventions must
be pragmatic.  If programmers are ultimately constrained rather than helped
by their environment, they will break the rules, and when they do so, they
will break them in inconsistent ways.  Therefore it is crucial that
consistency within the environment is achieved by conventions that are easy
to live with.  One example, discussed below, is in the rule governing the
relationship between header file names and the objects defined within that
header.  The general principle, then, is "as close to consistent as
comfortable, but no more".
</P><P>

<HR SIZE="6">
<A NAME="SEC14"></A>
<H3> 1.3.2 Names </H3>
<!--docid::SEC14::-->
<P>

Names are always the biggest issue in programming environments.  Uniform
naming is one of the most important aspects of a library, and part of the
design effort in v<EM>x</EM>l lay in choosing a good, workable scheme for the
naming of classes, functions and files.  On the other hand, few issues
cause as much debate as the choice of naming conventionts.  However, we are
lucky for two reasons: first, because we wish to run cross-platform, many
options are restricted; second, as we can never please everybody, we can
just choose a convention and pretend we all hate it.
</P><P>

First things first.  The name v<EM>x</EM>l itself refers to a collection of
libraries where the <EM>x</EM> is replaced by a one or two-letter code
describing the contents.
</P><P>

Second, do we use <CODE>MixedCaseIdentifiers</CODE> or
<CODE>lowercase_with_underscores</CODE>?   Well, a certain operating system
#defines 1300 of the <CODE>MixedCaseIdentifiers</CODE> in a header file.
Therefore, programs which use names like <CODE>LoadImage</CODE> may or may not
link.  For this reason, we chose the other ugly solution.
</P><P>

<A NAME="IDX2"></A>
<A NAME="IDX3"></A>
<A NAME="IDX4"></A>
For related reasons, source files in v<EM>x</EM>l all end in <CODE>.cxx</CODE>.
Template definitions, which are essentially header files (as they are not
separately compiled) but look like source files, are suffixed <CODE>.txx</CODE>.
</P><P>

Each class or function in a v<EM>x</EM>l library begins with the name of that
library, for example <CODE>vnl_matrix</CODE>.  This makes it easy to locate the
source code for any class, and easy to see the list of libraries on which
one's program depends.
</P><P>

<A NAME="IDX5"></A>
This scheme was chosen over namespaces because few compilers support
namespaces well, and their implications in large-scale development are as
yet poorly understood.
</P><P>

An obvious extension of this convention would be to insist that every class
or function (in fact, every globally visible symbol exported by a library),
should be defined in its own include file, yielding an easy relationship
between symbols and include statements.  However, such a scheme
imposes great demands on programmers, who must generate long lists of
includes, and on library writers who must create many files with very
little in each.  Pragmatism must rule if we are to avoid programmer
discomfort, thus chaos.  A rule that is still useful, and easier to adhere
to is used:
<BLOCKQUOTE>
The file <CODE>vxl/vxl_stuff.h</CODE> exports only identifiers which
begin <CODE>vxl_stuff</CODE>.
</BLOCKQUOTE>
An example of a header file which obeys this rule is shown in figure 1.
<P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>#ifndef vxl_stuff_h_
#define vxl_stuff_h_

enum vxl_stuff_things {
  vxl_stuff_bare,
  vxl_stuff_spartan
};

class vxl_stuff {
};

bool vxl_stuff_grok(vxl_stuff);
extern int vxl_stuffing;

#endif
</FONT></pre></td></tr></table><BLOCKQUOTE>
<STRONG>Figure 1:</STRONG>
Example of a header file <CODE>vxl_stuff.h</CODE> which obeys the naming
convention. Only identifiers that begin with <CODE>vxl_stuff</CODE> may be
defined.
</BLOCKQUOTE>
<P>

Of course, this rule is less helpful to clients of the library, who might
remember that there is a class called <CODE>vtl_thing_doer</CODE>, but not know
which header file to include.  However, the disadvantage is not great, as
the likely options are just <CODE>vtl/vtl_thing.h</CODE> and
<CODE>vtl/vtl_thing_doer.h</CODE>.  What is ultimately helpful to clients is a
uniform naming scheme, kept so by pragmatic constraints on the library
developers.
</P><P>

FAQ: What about <CODE>operator+(vcl_stuff, vcl_stuff)</CODE>?  Frequently given
half-answer: Koenig lookup means it's OK.
</P><P>

<HR SIZE="6">
<A NAME="SEC15"></A>
<H3> 1.3.3 Layering </H3>
<!--docid::SEC15::-->
Which brings us on to layering: core v<EM>x</EM>l libraries may not depend on
each other.  The numerics library cannot use the handy string manipulation
in vbl, the imaging library cannot use matrices, or smart pointers.  This
restriction is central to the design of v<EM>x</EM>l, because it intrinsically
limits the size of the core libraries.
It appears to contradict traditional software development practice because
it implies that code will be duplicated rather than reused.  However,
the amount of code duplicated is small, and the benefit of lego libraries
is enormous.   The current status is encapsulated in this figure
<TABLE><tr><td>&nbsp;</td><td class=example><pre>Level:   0         1         2          3
         vcl       vbl       vnl_algo   v**l
                   vnl       vil_algo
                   vil       vgl_algo
                   vgl
</pre></td></tr></table><BLOCKQUOTE>
Library layers: libraries in one layer may not call their
siblings, even if this means code copying.
</BLOCKQUOTE>
<P>

However, other alternatives have been considered, and may yet be
considered.  For example, what about putting vbl at level 0.5, so that
common utilities can be available to level 1?  The problem of course is
that everything will end up in the level 0.5 library.  We could impose the
rule that nothing goes in vbl unless it is used in at least two level 1
libraries.  I don't know whether that would help or not...
</P><P>

<A NAME="vcl"></A>
<HR SIZE="6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[ &lt;&lt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[ &gt;&gt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book_11.html#SEC56">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="book_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
</BODY>
</HTML>
