@chapsummary
Load images using @code{vil2_load}. Access them
 using a @code{vil2_image_view<T>}.
@endchapsummary

vil2 will replace parts of the existing vil image library in the near future.

The @vxl{} image library has evolved from the TargetJr and Manchester Image
libraries.
As with its predecessors, its primary goals is to provide flexible
to all 2D images, including those too large to fit in
the address space of a single program or process, and very powerful and
fast access to images in memory. In fact, both cases need similar
treatment: even in-core images are assumed to be sufficiently large (say a
megabyte) that special care must be taken to avoid unnecessary copying of
their data.  In both cases, the normal requirements of efficiency and
ease-of-use apply.  The system must allow:
@itemize @bullet
@item Beginners to have easy access to an image type. This image type
should also be the default image type for an programmer writing
image processing code. This image type must be very efficient to use.

@item Fast access to images on disk, at no more than a 10% speed penalty
for operations on images in memory.

@item Fast loading of subsets of the image data.  To look at a
small portion of a 10000 by 10000 pixel satellite image, one should
not have to load the entire 300 megabytes into memory.

@item Efficient memory management, both automatic and programmer-mediated.
Automatic management is vital during program development, when the code is
changing quickly.  On the other hand, release builds need the kind of
optimisations that only a human can apply.
@end itemize

@section Loading and saving
Let's look at an example of vil in use.  This program makes an image from a
disk file, copies it into memory, and prints the pixel at
100,100.

@example
#include <vcl_iostream.h>
#include <vxl_config.h>
#include <vil2/vil2_load.h>
#include <vil2/vil2_image_view.h>

int main()
@{
  vil2_image_view<vil_rgb<vxl_byte> > img;
  img = vil2_load("foo.ppm");
  vcl_cerr << "Pixel 100,100 = " << img(100,100) << vcl_endl;
@}
@end example

The first interesting line declares img to be an image. vil2_image_view
is the basic image type. It represents an image in memory about
whose structure, size and pixel type we know everything.
Hence we need to specify the pixel type at this point.

Now let's skip to the end to explain the pixel access method.
@example
  img(100,100)
@end example
This looks up the pixel at position 100,100 and returns its value. The
pixel type was defined on the first line to be an rgb of bytes, and
that is what will be displayed.
@example
[255 128 128]
@end example
Where it matters (such as when loading
an image in from disk) it is assumed that the image origin is at the
top left of the image.

Finally lets look at the middle line. This consists of two parts.
The @code{vil2_load} function does a lot of work behind the scenes
to determine what the image type is, and then load that image into
memory. The second part is the assignment which has several special properties.
@itemize @bullet
@item It does not copy the actual image data. A @code{vil2_image_view} object
is really a view of some underlying data. The view understands where the
real image data is in memory and how to interpret it. When you copy
a view, you merely copy this interpretation information, not the actual
image data. This is important, because often images are very big, and
copying is expensive. The underlying image is managed with smart pointers
so when the last view to the underlying data is destroyed, the image data
will be too.

@item It can do cheap conversions between different views of the same image.
@code{vil2_load} by default loads the image as 3 planes, with the pixel
type as @code{vxl_byte}. It is trivial to reconfigure a @code{vil2_image_view}
so that it views the same image data as one plane of rgb pixels. The
assignment will automatically do any cheap conversion necessary. You may
ask then, how is that we know that the pixel type can be viewed as RGB of bytes?
Here, we simply know that our image foo.ppm is this type. In general you can
either find out what the pixel type is before you load the image, or
you can force it to whatever pixel type you want. The latter may involve
a relatively expensive pixel by pixel conversion, so this will not happen
automatically.
@end itemize


@subsection Loading and saving: The threshold program
@cindex threshold example
@cindex vil2_save
Anyway, the usual next step in demonstrating an image handling library is
to show thresholding, so let's have a look.  This program loads an image
into memory, and creates a new image where all pixels greater than a
threshold value are set to 255.
@example
#include <vil/vil_rgb_byte>
#include <vil2/vil2_load.h>
#include <vil2/vil2_save.h>
#include <vil2/vil2_image_view.h>

int main()
@{
  vil2_image_view<vil_rgb_byte > img;
  img = vil2_load("foo.ppm");

  for(unsigned j = 0; j < img.height(); ++j)
    for(unsigned i = 0; i < img.width(); ++i)
      if (img(i,j).r < 200 && img(i,j).g < 200 && img(i,j).b < 200)
        img(i,j) = vil_rgb_byte(0,0,0);

  vil2_save(img, "foothresh.ppm");
  return 0;
@}
@end example

The call to @code{vil2_save} sends the modified image in @var{img} to disk.
The choice of file format is determined automatically from the extension of
the filename.  In this case, the extension is "ppm", the Portable Pix Map
format.  If one wants more control, a string can be appended to specify the
format, e.g.
@cindex vil2_save, choosing a specific file format
@example
  vil2_save(buf, "foothresh.ppm", "jpeg");
@end example
Of course, it's rarely sensible to have incompatible names and formats, but
the user of your program may have chosen the name, so that you have no
other option.

@section Copying an image
@cindex images, copying
You should know by now that copying @code{vil2_image_view} objects does not
duplicate the data they point to.  This allows images to be passed into and
out of functions efficiently.  It also means that modifying the data in one
@code{vil2_image_view} might change that in another.  Take this example
@example
...
vil2_image_view<float> a( vil2_load("x") );
vil2_image_view<float> b = a;
b(100,100) = 12;
...
@end example
After the assignment in line 3, both @var{a(100,100)} and @var{b(100,100)}
are set to the value 12.  On the other hand, if we had used
@code{vil2_copy_deep}, thus:
@example
...
vil2_image_view<float> a( vil2_load("x") );
vil2_copy_deep(a, b);
b(100,100) = 12;
...
@end example
or
@example
...
vil2_image_view<float> a( vil2_load("x") );
vil2_image_view<float> b( vil2_copy_deep(a) );
b(100,100) = 12;
...
@end example
then @var{a} is unchanged after the assignment to @var{b(100,100)}.
Note again that the actual copying is done in @code{vil2_copy_deep}; when the
return value is assigned to @var{b}, there is an efficient view copy.

@section Large images

Broadly there are two sorts of image one is interested in - images
in memory (all parts of which can be accessed directly) and
external images (eg in files) which can only be accessed
indirectly. As we have seen those images in memory are represented
by @code{vil2_image_view}. For some very large images it is not
possible or desirable to load them into memory. In this case it is
useful to be able to load in a sub-section of the image,
manipulate it, and possible write it out again. vil2 supports this
approach using @code{vil2_image_resource}. There are several types of
image resource, described below. You cannot create an image
resource object directly, instead you use a creation function
which returns a smart pointer to the base class
@code{vil2_image_resource_sptr}.

@itemize @bullet
@item Representing an image in a file: e.g. @code{vil2_pnm_image},
@code{vil2_jpeg_image}. These are created using
@code{vil2_load_image_data()},
and @code{vil2_new_image_resource()}.

@item @code{vil2_memory_image}: Representing an image in memory
(essentially a
wrapper around a view.) This is created using
@code{vil2_new_image_resource()}.

@item Representing a filtered version of an
image in a file (without loading in memory): e.g.
@code{vil2_crop_image_resource} and
@code{vil2_decimate_image_resource}. These
are created using the equivalent functions: @code{vil2_crop()},
@code{vil2_decimate()}, etc.

@item Representing the outcome of an image
processing algorithm (see next section) e.g.
@code{vil2_convolve_1d_resource}.
These are creates using the equivalent
functions e.g. @code{vil2_convolve_1d()}.

@end itemize

To actually get some image pixels you call the resource's
@code{get_view(..)} or @code{get_copy_view(..)} method.
The @code{vil2_load(..)} function works by creating
a @code{vil2_image_resource}, and then calling @code{get_view(..)}
for the whole image.
@example
vil2_image_view_base_sptr vil2_load(const char *file)
@{
  vil2_image_resource_sptr data = vil2_load_image_resource(file);
  if (!data) return 0;
  return data -> get_view(0, data->ni(), 0, data->nj());
@}
@end example

@section Planes, components and stepping.
@cindex image layout
@cindex planes
@cindex components

@code{vil2_image_view}
uses a pointer arithmetic style of indexing.
The image data is assumed to be a regularly arranged set of
pixels in memory. The view keeps a pointer to the pixel
at the origin. It also keeps the pointer difference to
get to the next pixel to the right, the next pixel down,
and the same pixel in the next plane.

In a general image representation a 2d image
consists of multiple planes each containing multiple rasters (rows)
each containing multiple pixels, and each pixel contains multiple
components. The planes and the components are used for the same
purpose, to represent different spectral or functional values (e.g. the
red, green and blue channels of an RGB image.) In vil2 it is usually
assumed that an image cannot have both multiple planes and multiple
components per pixel. This allows
@code{vil2_image_view} to view the same a colour image data
as either a 3 plane image or a 1 plane RGB image. You can do this
explicitly by calling @code{vil2_view_as_planes()} or @code{vil2_view_as_rgb()}.

However the two representations are not equal. The
multi-plane representation
is more general than the RGB multi-component one. If
the underlying data is actually stored RRRR..GGGG..BBBB..
then it is not possible to view that image as a single
plane of RGB pixels. For this reason, a lot of vil2 prefers
to view an image as multi-plane single-component.

@cindex view manipulations
Similarly to the planes to components conversion
it is possible to perform a whole range of other manipulations. These
include @code{vil2_transpose()}, @code{vil2_flip_ud()},
@code{vil2_decimate()}, @code{vil2_crop()}.
One further advantage of the arithmetic indexing scheme is that
it becomes easy to create a 2d slice view of a 3d image.


@section Algorithms and Image Processing

Several image processing functions can be found in the algo
subdirectory of vil2. Lets look at an example of finding the image
gradient using a Sobel filter.


@example
#include <vcl_iostream.h>
#include <vxl_config.h> // for vxl_byte
#include <vil2/vil2_image_view.h>
#include <vil2/vil2_print.h>
#include <vil2/algo/vil2_sobel_3x3.h>

int main()
@{
  unsigned ni=8;
  unsigned nj=15;
  unsigned nplanes=1;
  vil2_image_view<vxl_byte> image(ni,nj,nplanes);

  for (unsigned p=0;p<nplanes;++p)
    for (unsigned j=0;j<nj;++j)
      for (unsigned i=0;i<ni;++i)
        image(i,j,p) = vxl_byte(i+10*j+100*p);

  vcl_cout<<"Original image:"<<vcl_endl;
  vil2_print_all(vcl_cout,image);

    // Objects to hold gradients
  vil2_image_view<float> grad_i,grad_j;

  vil2_sobel_3x3(image,grad_i,grad_j);

  vcl_cout<<vcl_endl;
  vcl_cout<<"Sobel I Gradient:"<<vcl_endl;
  vil2_print_all(vcl_cout,grad_i);

  vcl_cout<<vcl_endl;
  vcl_cout<<"Sobel J Gradient:"<<vcl_endl;
  vil2_print_all(vcl_cout,grad_j);

  return 0;
@}
@end example

There are also algorithms to perform image arithmetic,
smoothing, general 1D and 2D
convolution, morphological operations, interpolation,
and much more.


@section Optimising Image Processing Algorithms

The design of vil2_image_view (being more flexible than the design of vil,)
and the state of modern optimising compilers (no near as good as they
could be,) means that naive use of vil2 images may not be as fast as it
should be.

The following example shows the original implementation of
the image fill method.
@example
template<class T>
void vil2_image_view<T>::fill(T value)
@{
  for (unsigned p=0;p<nplanes_;++p)
    for (unsigned j=0;j<nj_;++j)
      for (unsigned i=0;i<ni_;++i)
        (*this)(i,j,p)= v;
@}
@end example
This implementation has the advantage of being simple, and easy to test.


In an ideal world the compiler would realise that it doesn't
have to recalculate the location of each pixel each step. (Of course, in
an ideal world we would be programing using natural language and
a microphone.)
We can make this optimisation explicit.


@example
template<class T>
void vil2_image_view<T>::fill(T value)
@{
  T* plane = top_left_;
  for (unsigned int p=0;p<nplanes_;++p,plane += planestep_)
  @{
    T* row = plane;
    for (unsigned int j=0;j<nj_;++j,row += jstep_)
    @{
      T* p = row;
      for (unsigned int i=0;i<ni_;++i,p+=istep_) *p = value;
    @}
  @}
@}
@end example
This can halve the run time on some compilers.

One important approach in code optimisation is to observe how the code
behaves in real life, and concentrate your efforts on where the code
spends most of its time. In our example, this means the inner most loop
Now, it turns out that in many cases, @code{istep_==1}, because of the
default image layout in memory. Because of this common case it would
be worth having the compiler generate machine-code for the inner-most
loop in this special case. We can do this by explicitly testing for
such a special case.


@example
template<class T>
void vil2_image_view<T>::fill(T value)
@{
  T* plane = top_left_;

  if (istep_==1)
  @{
    for (unsigned int p=0;p<nplanes_;++p,plane += planestep_)
    @{
      T* row = plane-1;
      for (unsigned int j=0;j<nj_;++j,row += jstep_)
      @{
        int i = ni_ ;
        while (i>=0) { row[i--]=value; }
      @}
    @}
    return;
  @}

  for (unsigned int p=0;p<nplanes_;++p,plane += planestep_)
  @{
    T* row = plane;
    for (unsigned int j=0;j<nj_;++j,row += jstep_)
    @{
      T* p = row;
      for (unsigned int i=0;i<ni_;++i,p+=istep_) *p = value;
    @}
  @}
@}
@end example


There are two other optimisations going on here. The first is that
we are using the pointer indexing operator @code{[]}. Most compilers
treat @code{while(i<n)@{*(ptr++)=v;@} } differently from
@code{while(i<n)@{ptr[i++]=v;@} }, with the latter often
being significantly faster. This is especially true when ptr is a pointer
to a character sized type.
The other optimisation makes use of the fact that it is faster to count down to
0 than count up to n. This is because it is faster to test against a constant, 0,
than against a variable. Sometimes a compiler figures this out itself,
but by no means always. One useful refinement that may be possible is to
decrement the index counter right at the end of the loop. This allows the
compiler to avoid issuing a separate test instruction, since this sort
of test is automatically performed by the processor after a decrement
or other arithmetic operation.


Since we are performing the same operation on every pixel independent
of its absolute or relative position, there is one further optimisation
that can be performed. In many cases an image will be stored as a
contiguous block of memory. If this is the case, it may make sense
just to operate on this block of memory as a single dimensional array.
In the case of fill, this may even allow a compiler to issue
a specialised single machine instruction which performs the whole
fill very very fast. This gives us our final implementation.



@example
template<class T>
void vil2_image_view<T>::fill(T value)
@{
  T* plane = top_left_;

  if (is_contiguous())
  @{
    vil2_image_view<T>::iterator it = begin();
    vil2_image_view<T>::const_iterator end_it = end();
    while (it!=end_it) {*it = value; ++it; }
    return;
  @}

  if (istep_==1)
  @{
    for (unsigned int p=0;p<nplanes_;++p,plane += planestep_)
    @{
      T* row = plane-1;
      for (unsigned int j=0;j<nj_;++j,row += jstep_)
      @{
        int i = ni_;
        while (i>=0) { row[i--]=value; }
      @}
    @}
    return;
  @}

  for (unsigned int p=0;p<nplanes_;++p,plane += planestep_)
  @{
    T* row = plane;
    for (unsigned int j=0;j<nj_;++j,row += jstep_)
    @{
      T* p = row;
      for (unsigned int i=0;i<ni_;++i,p+=istep_) *p = value;
    @}
  @}
@}
@end example


This optimised version was between two and ten times faster than the original
depending on the compiler, image structure, and pixel type.


It should always be born in mind that there is a trade-off in testing for
special cases. Each test takes time, and this slows the function down
for the non-special cases. Limit yourself to only testing for very common
cases that have very significant potential speed improvements.

Finally as with all optimisation - be rigorous in comparing the actual
times for your original and optimised code. Run enough experiments to
measure the statiscal spread to see if your improvements are significant.
It is quite common for compiler or processor
quirks to make your optimised code slower than the original.
