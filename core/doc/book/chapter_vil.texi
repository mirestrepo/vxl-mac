@chapsummary
Load images using @code{vil_load}. Access them
 using a @code{vil_image_view<T>}.
@endchapsummary

The @vxl{} image library has evolved from the TargetJr and Manchester Image
libraries.
As with its predecessors, its primary goals is to provide flexible
to all 2D images, including those too large to fit in
the address space of a single program or process, and very powerful and
fast access to images in memory. In fact, both cases need similar
treatment: even in-core images are assumed to be sufficiently large (say a
megabyte) that special care must be taken to avoid unnecessary copying of
their data.  In both cases, the normal requirements of efficiency and
ease-of-use apply.  The system must allow:
@itemize @bullet
@item Beginners to have easy access to an image type. This image type
should also be the default image type for an programmer writing
image processing code. This image type must be very efficient to use.

@item Fast access to images on disk, at no more than a 10% speed penalty
for operations on images in memory.

@item Fast loading of subsets of the image data.  To look at a
small portion of a 10000 by 10000 pixel satellite image, one should
not have to load the entire 300 megabytes into memory.

@item Efficient memory management, both automatic and programmer-mediated.
Automatic management is vital during program development, when the code is
changing quickly.  On the other hand, release builds need the kind of
optimisations that only a human can apply.
@end itemize

This vil library is the second VXL image library, and is sometimes referred
to as vil2. The original  @vxl{} image library vil1 is deprecated.

@section Loading and saving
Let's look at an example of vil in use.  This program makes an image from a
disk file, copies it into memory, and prints the pixel at
100,100.

@example
#include <vcl_iostream.h>
#include <vxl_config.h>
#include <vil/vil_rgb.h>
#include <vil/vil_load.h>
#include <vil/vil_image_view.h>

int main()
@{
  vil_image_view<vil_rgb<vxl_byte> > img;
  img = vil_load("foo.ppm");
  vcl_cerr << "Pixel 100,100 = " << img(100,100) << vcl_endl;
@}
@end example

The first interesting line declares img to be an image. vil_image_view
is the basic image type. It represents an image in memory about
whose structure, size and pixel type we know everything.
Hence we need to specify the pixel type at this point.

Now let's skip to the end to explain the pixel access method.
@example
  img(100,100)
@end example
This looks up the pixel at position 100,100 and returns its value. The
pixel type was defined on the first line to be an rgb of bytes, and
that is what will be displayed.
@example
[255 128 128]
@end example
Where it matters (such as when loading
an image in from disk) it is assumed that the image origin is at the
top left of the image.

Finally lets look at the middle line. This consists of two parts.
The @code{vil_load} function does a lot of work behind the scenes
to determine what the image type is, and then load that image into
memory. The second part is the assignment which has several special properties.
@itemize @bullet
@item It does not copy the actual image data. A @code{vil_image_view} object
is really a view of some underlying data. The view understands where the
real image data is in memory and how to interpret it. When you copy
a view, you merely copy this interpretation information, not the actual
image data. This is important, because often images are very big, and
copying is expensive. The underlying image is managed with smart pointers
so when the last view to the underlying data is destroyed, the image data
will be too.

@item It can do cheap conversions between different views of the same image.
@code{vil_load} by default loads the image as 3 planes, with the pixel
type as @code{vxl_byte}. It is trivial to reconfigure a @code{vil_image_view}
so that it views the same image data as one plane of rgb pixels. The
assignment will automatically do any cheap conversion necessary. You may
ask then, how is that we know that the pixel type can be viewed as RGB of bytes?
Here, we simply know that our image foo.ppm is this type. In general you can
either find out what the pixel type is before you load the image, or
you can force it to whatever pixel type you want. The latter may involve
a relatively expensive pixel by pixel conversion, so this will not happen
automatically.
@end itemize


@subsection Loading and saving: The threshold program
@cindex threshold example
@cindex vil_save
Anyway, the usual next step in demonstrating an image handling library is
to show thresholding, so let's have a look.  This program loads an image
into memory, and creates a new image where all pixels greater than a
threshold value are set to 0.
@example
#include <vxl_config.h>
#include <vil/vil_rgb.h>
#include <vil/vil_load.h>
#include <vil/vil_save.h>
#include <vil/vil_image_view.h>

int main()
@{
  vil_image_view<vil_rgb<vxl_byte> > img;
  img = vil_load("foo.ppm");

  for (unsigned j = 0; j < img.height(); ++j)
    for (unsigned i = 0; i < img.width(); ++i)
      if (img(i,j).r < 200 && img(i,j).g < 200 && img(i,j).b < 200)
        img(i,j) = vil_rgb<vxl_byte>(0,0,0);

  vil_save(img, "foothresh.ppm");
  return 0;
@}
@end example

The call to @code{vil_save} sends the modified image in @var{img} to disk.
The choice of file format is determined automatically from the extension of
the filename.  In this case, the extension is "ppm", the Portable Pix Map
format.  If one wants more control, a string can be appended to specify the
format, e.g.
@cindex vil_save, choosing a specific file format
@example
  vil_save(buf, "foothresh.ppm", "jpeg");
@end example
Of course, it's rarely sensible to have incompatible names and formats, but
the user of your program may have chosen the name, so that you have no
other option.

@section Copying an image
@cindex images, copying
You should know by now that copying @code{vil_image_view} objects does not
duplicate the data they point to.  This allows images to be passed into and
out of functions efficiently.  It also means that modifying the data in one
@code{vil_image_view} might change that in another.  Take this example
@example
...
vil_image_view<float> a( vil_load("x") );
vil_image_view<float> b = a;
b(100,100) = 12;
...
@end example
After the assignment in line 3, both @var{a(100,100)} and @var{b(100,100)}
are set to the value 12.  On the other hand, if we had used
@code{vil_copy_deep}, thus:
@example
...
vil_image_view<float> a( vil_load("x") );
vil_copy_deep(a, b);
b(100,100) = 12;
...
@end example
or
@example
...
vil_image_view<float> a( vil_load("x") );
vil_image_view<float> b( vil_copy_deep(a) );
b(100,100) = 12;
...
@end example
then @var{a} is unchanged after the assignment to @var{b(100,100)}.
Note again that the actual copying is done in @code{vil_copy_deep}; when the
return value is assigned to @var{b}, there is an efficient view copy.

@section Large images

Broadly there are two sorts of image one is interested in - images
in memory (all parts of which can be accessed directly) and
external images (eg in files) which can only be accessed
indirectly. As we have seen those images in memory are represented
by @code{vil_image_view}. For some very large images it is not
possible or desirable to load them into memory. In this case it is
useful to be able to load in a sub-section of the image,
manipulate it, and possible write it out again. vil supports this
approach using @code{vil_image_resource}. There are several types of
image resource, described below. You cannot create an image
resource object directly, instead you use a creation function
which returns a smart pointer to the base class
@code{vil_image_resource_sptr}.

@itemize @bullet
@item Representing an image in a file: e.g. @code{vil_pnm_image},
@code{vil_jpeg_image}. These are created using
@code{vil_load_image_data()},
and @code{vil_new_image_resource()}.

@item @code{vil_memory_image}: Representing an image in memory
(essentially a
wrapper around a view.) This is created using
@code{vil_new_image_resource()}.

@item Representing a filtered version of an
image in a file (without loading in memory): e.g.
@code{vil_crop_image_resource} and
@code{vil_decimate_image_resource}. These
are created using the equivalent functions: @code{vil_crop()},
@code{vil_decimate()}, etc.

@item Representing the outcome of an image
processing algorithm (see next section) e.g.
@code{vil_convolve_1d_resource}.
These are creates using the equivalent
functions e.g. @code{vil_convolve_1d()}.

@end itemize

To actually get some image pixels you call the resource's
@code{get_view(..)} or @code{get_copy_view(..)} method.
The @code{vil_load(..)} function works by creating
a @code{vil_image_resource}, and then calling @code{get_view(..)}
for the whole image.
@example
vil_image_view_base_sptr vil_load(const char *file)
@{
  vil_image_resource_sptr data = vil_load_image_resource(file);
  if (!data) return 0;
  return data -> get_view(0, data->ni(), 0, data->nj());
@}
@end example

@section Planes, components and stepping.
@cindex image layout
@cindex planes
@cindex components

@code{vil_image_view}
uses a pointer arithmetic style of indexing.
The image data is assumed to be a regularly arranged set of
pixels in memory. The view keeps a pointer to the pixel
at the origin. It also keeps the pointer difference to
get to the next pixel to the right, the next pixel down,
and the same pixel in the next plane.

In a general image representation a 2d image
consists of multiple planes each containing multiple rasters (rows)
each containing multiple pixels, and each pixel contains multiple
components. The planes and the components are used for the same
purpose, to represent different spectral or functional values (e.g. the
red, green and blue channels of an RGB image.) In vil it is usually
assumed that an image cannot have both multiple planes and multiple
components per pixel. This allows
@code{vil_image_view} to view the same a colour image data
as either a 3 plane image or a 1 plane RGB image. You can do this
explicitly by calling @code{vil_view_as_planes()} or @code{vil_view_as_rgb()}.

However the two representations are not equal. The
multi-plane representation
is more general than the RGB multi-component one. If
the underlying data is actually stored RRRR..GGGG..BBBB..
then it is not possible to view that image as a single
plane of RGB pixels. For this reason, a lot of vil prefers
to view an image as multi-plane single-component.

@cindex view manipulations
Similarly to the planes to components conversion
it is possible to perform a whole range of other manipulations. These
include @code{vil_transpose()}, @code{vil_flip_ud()},
@code{vil_decimate()}, @code{vil_crop()}.
One further advantage of the arithmetic indexing scheme is that
it becomes easy to create a 2d slice view of a 3d image.


@section Algorithms and Image Processing

Several image processing functions can be found in the algo
subdirectory of vil. Lets look at an example of finding the image
gradient using a Sobel filter.

@example
#include <vcl_iostream.h>
#include <vxl_config.h> // for vxl_byte
#include <vil/vil_image_view.h>
#include <vil/vil_print.h>
#include <vil/algo/vil_sobel_3x3.h>

int main()
@{
  unsigned ni=8;
  unsigned nj=15;
  unsigned nplanes=1;
  vil_image_view<vxl_byte> image(ni,nj,nplanes);

  for (unsigned p=0;p<nplanes;++p)
    for (unsigned j=0;j<nj;++j)
      for (unsigned i=0;i<ni;++i)
        image(i,j,p) = vxl_byte(i+10*j+100*p);

  vcl_cout<<"Original image:"<<vcl_endl;
  vil_print_all(vcl_cout,image);

    // Objects to hold gradients
  vil_image_view<float> grad_i,grad_j;

  vil_sobel_3x3(image,grad_i,grad_j);

  vcl_cout<<vcl_endl;
  vcl_cout<<"Sobel I Gradient:"<<vcl_endl;
  vil_print_all(vcl_cout,grad_i);

  vcl_cout<<vcl_endl;
  vcl_cout<<"Sobel J Gradient:"<<vcl_endl;
  vil_print_all(vcl_cout,grad_j);

  return 0;
@}
@end example

There are also algorithms to perform image arithmetic,
smoothing, general 1D and 2D
convolution, morphological operations, interpolation,
and much more.

@section Converting from using the old vil1 to vil.

This section explores the major differences between using the old vil1
and using vil, and some of the implications for converting existing code.

The first and most obvious difference is that whilst there is a broad equivalent to
vil1_image, and its descendants, this class tree has been split in two. The abstract
@code{vil1_image} is now replaced with a smart pointer to a @code{vil_image_resource}.
The concrete @code{vil1_memory_image_of} is now a @code{vil_image_view<>}
Previously where as you might have written code in terms of vil1_image, it now
usually makes sense to have most image manipulations working on
@code{vil_image_view}s. This is because whilst with the old vil1_image, you had to
do a @code{get_section}, and operate on raw memory, in vil, the @code{vil_image_view}
provides a powerful view directly onto your image in memory.

The @code{vil_image_view} provides such facilities
as compile-time type safety as switchable bounds checking. It also acts as a
sort of canonicaliser. A wide range of actual memory layouts can all be treated
identically and transparently while working through the @code{vil_image_view}.
Previously, in vil1, the image loader often needed to have several filters placed
on top of it to do such things as re-order the raster rows and re-order the
component order. vil doesn't do this, but instead uses the vil_image_view to provide
a canonical view of whatever deranged image format your loader finds most efficient to
use.

The second important change is that vil provides full support for planes. In many cases
accessing different image planes is directly equivalent to accessing different components.
Indeed, it is often preferable to view an image as a multi-planar rather than multi-component.
If your algorithms assume a single plane, it is however trivial to provide a wrapper function
which takes a multi-planar image and passes one plane at a time to your algorithm. This
can be done with virtually no loss in efficiency, and indeed is how some of the code in
@code{vil/algo} is written.

To help convert existing code there is a script (@code{core/vil/scripts/vil1tovil.pl})
It converts as much code as it can. However, it can really only deal with file and identifier
name changes. There are large structural differences between vil1 and vil, with many of the
equivalent functions taking different parameters. The output of the conversion script
can best be seen as a hint on which types and classes to use and which functions to call.
You will almost certainly need to make extensive further edits to your code to get it
to compile again.

If you do not want to convert any code, but would rather use an interface to convert
between vil1 and vil types at runtime, then take a look at @code{<vil1/vil1_vil.h>}
which has a function for converting between @code{vil1_memory_image_of} and @code{vil_image_view}, and
a class that wraps a @code{vil1_image}, and exports a @code{vil_image_resource} interface.


@section Optimising Image Processing Algorithms (Advanced Topic)

The design of vil_image_view (being more flexible than the design of vil1,)
and the state of modern optimising compilers (no near as good as they
could be,) means that naive use of vil images may not be as fast as it
should be.

The following example shows the original implementation of
the image fill method.
@example
template<class T>
void vil_image_view<T>::fill(T value)
@{
  for (unsigned p=0;p<nplanes_;++p)
    for (unsigned j=0;j<nj_;++j)
      for (unsigned i=0;i<ni_;++i)
        (*this)(i,j,p)= v;
@}
@end example
This implementation has the advantage of being simple, and easy to test.


In an ideal world the compiler would realise that it doesn't
have to recalculate the location of each pixel each step, but instead keep
a running pointer to the current pixel location. (Of course, in
an ideal world we would be programming using natural language and
a microphone.)
We can make this optimisation explicit.

@example
template<class T>
void vil_image_view<T>::fill(T value)
@{
  T* plane = top_left_;
  for (unsigned p=0; p<nplanes_; ++p, plane+=planestep_)
  @{
    T* row = plane;
    for (unsigned j=0; j<nj_; ++j, row+=jstep_)
    @{
      T* p = row;
      for (unsigned i=0; i<ni_; ++i, p+=istep_) *p = value;
    @}
  @}
@}
@end example
This can halve the run time on some compilers.

The most important rule in code optimisation is to observe how the code
behaves in real life, and concentrate your efforts on where the code
spends most of its time. In our example, this means the inner most loop
Now, it turns out that in many cases, @code{istep_==1}, because of the
default image layout in memory. Because of this common case it would
be worth having the compiler generate machine-code for the inner-most
loop in this special case. We can do this by explicitly testing for
such a special case.

@example
template<class T>
void vil_image_view<T>::fill(T value)
@{
  T* plane = top_left_;

  if (istep_==1)
  @{
    for (unsigned p=0;p<nplanes_;++p,plane += planestep_)
    @{
      T* row = plane-1;
      for (unsigned j=0;j<nj_;++j,row += jstep_)
      @{
        int i = ni_ ;
        while (i>=0) { row[i--]=value; }
      @}
    @}
    return;
  @}

  for (unsigned p=0;p<nplanes_;++p,plane += planestep_)
  @{
    T* row = plane;
    for (unsigned j=0;j<nj_;++j,row += jstep_)
    @{
      T* p = row;
      for (unsigned i=0;i<ni_;++i,p+=istep_) *p = value;
    @}
  @}
@}
@end example

There are two other optimisations going on here. The first is that
we are using the pointer indexing operator @code{[]}. Most compilers
treat @code{while (++i<n) @{ *(ptr++)=v; @} } differently from
@code{while (++i<n) @{ ptr[i]=v; @} }, with the latter often
being significantly faster. This is especially true when @code{ptr}
is a pointer to a character sized type.
The other optimisation makes use of the fact that it is faster to count down to
0 than count up to n. This is because it is faster to test against a constant, 0,
than against a variable. Sometimes a compiler figures this out itself,
but by no means always. One useful refinement that may be possible is to
decrement the index counter right at the end of the loop. This allows the
compiler to avoid issuing a separate test instruction, since this sort
of test is automatically performed by the processor after a decrement
or other arithmetic operation.

Since we are performing the same operation on every pixel independent
of its absolute or relative position, there is one further optimisation
that can be performed. In many cases an image will be stored as a
contiguous block of memory. If this is the case, it may make sense
just to operate on this block of memory as a single dimensional array.
In the case of fill, this may even allow a compiler to issue
a specialised single machine instruction which performs the whole
fill very very fast. This gives us our final implementation.

@example
template<class T>
void vil_image_view<T>::fill(T value)
@{
  T* plane = top_left_;

  if (is_contiguous())
  @{
    vil_image_view<T>::iterator it = begin();
    vil_image_view<T>::const_iterator end_it = end();
    while (it!=end_it) {*it = value; ++it; }
    return;
  @}

  if (istep_==1)
  @{
    for (unsigned p=0;p<nplanes_;++p,plane += planestep_)
    @{
      T* row = plane-1;
      for (unsigned j=0;j<nj_;++j,row += jstep_)
      @{
        int i = ni_;
        while (i>=0) { row[i--]=value; }
      @}
    @}
    return;
  @}

  for (unsigned p=0; p<nplanes_; ++p, plane+=planestep_)
  @{
    T* row = plane;
    for (unsigned j=0; j<nj_; ++j, row+=jstep_)
    @{
      T* p = row;
      for (unsigned i=0; i<ni_; ++i, p+=istep_) *p = value;
    @}
  @}
@}
@end example

This optimised version was between two and ten times faster than the original
depending on the compiler, image structure, and pixel type.

It should always be born in mind that there is a trade-off in testing for
special cases. Each test takes time, and this slows the function down
for the non-special cases. Limit yourself to only testing for very common
cases that have very significant potential speed improvements.

Finally as with all optimisation - be rigorous in comparing the actual
times for your original and optimised code. Run enough experiments to
measure the statistical spread to see if your improvements are significant.
It is quite common for compiler or processor
quirks to make your optimised code slower than the original.
