#! /bin/sh
exec perl -w -x $0 ${1+"$@"}
#!perl
#line 5

# Purpose: list all files in the vxl source tree that have tab characters
# (and that shouldn't have them because vxl c++ source files shouldn't).

undef $/;
$full = "";

while (defined($ARGV[0]) && $ARGV[0] =~ m/^-/) {
  $_ = shift(@ARGV);
  if (m/^-f$/) {
    $full = 1;
  }
  else {
    printf STDERR "Unrecognised command line option $_ ignored\n";
  }
}

if (defined($ARGV[0])) {
  @FILES = @ARGV;
}
else {
  $IUEROOT = $ENV{IUEROOT};
  unless (defined($IUEROOT)) {
    print STDERR "IUEROOT is not defined, and no command line arguments were given\n";
    exit 0;
  }
  $FILES = `find $IUEROOT/config $IUEROOT/vcl $IUEROOT/v3p $IUEROOT/vxl $IUEROOT/mul $IUEROOT/oxl $IUEROOT/gel $IUEROOT/tbl $IUEROOT/conversions $IUEROOT/rpl $IUEROOT/oul -type f \\\( -name \\\*.cxx -o -name \\\*.txx -o -name \\\*.cc -o -name \\\*.cpp -o -name \\\*.c -o -name \\\*.h \\\) -print|grep -v /gel/\.v.ol\\.new/`;
  @FILES = split(' ', $FILES);
}

foreach $f (@FILES)
{
  unless (open(FILE, $f)) {
    print STDERR "File $f does not exist\n";
    next;
  }
  $file=<FILE>;
  close FILE;
  next unless (defined($file));
  $printed = $full;

# 1. abnormal characters (tabs, ascii < 32, etc.)
  if ($file =~ m/\t/) {
    print "$f\t\# contains tabs\n";
    $printed = 1;
  }
  if ($file =~ m/\r/ && $f !~ m/\.ds[pw]$/) {
    print "$f\t\# contains carriage returns (ascii 13)\n";
    $printed = 1;
  }
  if ($file =~ m/[\000-\010\013\014\016-\037\177-\277\320\327\336\360\367\376]/) {
    print "$f\t\# contains non-standard ascii characters\n";
    $printed = 1;
  }

# 2. spaces (more than 1) at end of line
  $has_end_spaces = ($file =~ m/  +\n/);

# 3. Lines longer than 132 characters
  if ($file =~ m/[^\n]{133,}/ && $f !~ m/\.dsp$/) {
    print "$f\t\# has lines of more than 132 characters\n";
    $printed = 1;
  }

# 4. Consecutive comment blocks, separated by blank lines
  if ($file =~ m!\n\s*//:[^\n]*\n( *// [^\n]*\n)*\s*\n\s*// !) {
    print "$f\t\# contains comment blocks separated by a blank line; consider joining them\n";
    $printed = 1;
  }

# 5. Quick consistency check of Doxygen structured comments
  if ($file =~ m!\n\s*//:! && $file !~ m!\n\s*//:(\s*\n\s*//)?\s*\\file\b! &&
                              $file !~ m!^\s*//:(\s*\n\s*//)?\s*\\file\b!) {
    print "$f\t\# doxygen comments will not be shown without \\file\n";
    $printed = 1;
  }
  if ($file =~ m!//\s*\\file[ \t]+(\S[^\n]*)!) {
    print "$f\t\# doxygen \\file better not have an argument, so remove \"$1\"\n";
    $printed = 1;
  }
  if ($file =~ m!\n\s*//(:|\s*\\brief\b)([^\n]{40,})\n *// *([a-z]\S*)!) {
    unless ($2 =~ m/[.?!]$/ || $3 =~ m/^v[bcginpsu]l_/) {
      print "$f\t\# brief comment possibly continued on next line: \"$2\\n$3 ...\"\n";
      $printed = 1;
    }
  }
  elsif ($file =~ m!\n\s*//(:|\s*\\brief\b)([^\n]{40,}\b(and|if|but|since|that|,))\n *//!i) {
    print "$f\t\# brief comment possibly continued on next line: \"$2\\n$3 ...\"\n";
    $printed = 1;
  }

# 6. Unnecessary #include files and missing #include files.
#   Unnecessary includes are in principle anything which is not
#   used or directly referred to in the current file.
#   Missing includes is currently only vcl_cassert.h
  $includes = "\004\n$file\003";
  $includes =~ s/\n\s*\#\s*include\s\<([^>]+)\>[^\n]*/\003$1\004/g;
  $includes =~ s/^[^\003]*\003/\003/; $includes =~ s/\004[^\004]*$/\004/;
  $includes =~ s/\004[^\003]*\003/\n/g; $includes =~ s/[\004\003]//g;
  @includes = sort(split('\n', $includes));
  $jj = ""; $found_cassert = "";
  foreach $j (@includes)
  {
    next if ($j eq "");
    $found_cassert = 1 if ($j eq "vcl_cassert.h" || $j eq "assert.h");
    print "$f\t\# invalid #include <$j>\n"
      unless ($j =~ m/\.(h|H|txx)$/ || $f =~ m/\/vcl\// ||
              ($j eq "std/complext.cc" && $f =~ m/\/vnl\/vnl_(bignum|rational)\.cxx$/));
    next unless ($j =~ m/\.h$/i);
    next if ($f =~ m/(v.l)\/tests\/(\1_)?test_(includes?|all)\.cxx$/ && $j =~ m/^$1(\/algo)?\/$1_/);
    next if ($f =~ m/vnl\/algo\/Templates\/vcl_vector\+vnl_amoeba_SimplexCorner-\.cxx$/ && $j eq "vnl/algo/vnl_amoeba.h");
    next if ($f =~ m/vnl\/vnl_math\.cxx$/ && $j eq "math.h");
    next if ($f =~ m/vpl\/vpl\.cxx$/ && $j eq "vpl/os_unix/vpl.cxx");
    next if ($f =~ m/vbl_test_smart_ptr\.cxx$/ && $j eq "vbl/vbl_smart_ptr.h");
    print "$f\t\# has multiple occurrence of \#include <$j>\n"
      if ($j eq $jj &&
          $f !~ m/\/vcl\/vcl_(cstddef|climits|new|sys\/time)\.h$/ &&
          $f !~ m/\/vcl\/tests\/test_vcl_stlfwd\.cxx$/ &&
          $f !~ m/\/v.l\/io\/tests\/golden_test_v.l_io\.cxx$/ &&
          $j !~ m/^(stdlib|varargs|sys\/types|stdio|windows|GL\/glu?t?)\.h$/);
    $jj = $j; $i = $j;
    next unless ($i =~ s/^(vnl|vil|vsl|vul|vpl|vgl|vbl|vtol|vsol|vipl\/vipl_with_[a-z_]+|vipl|vepl|mbl|mil)\/(algo\/|io\/|internals\/|filter\/|section\/|vrml\/|impl\/(X|glut|gtk|mfc)\/|)(.*)\.h/$4/ || $i =~ s/^(vcl_(complex|string|deque|list|map|queue|stack|vector|iostream))\.h$/$1/ || $i =~ s/^vcl_c(assert|errno|setjmp)\.h$/$1/);
    next if ($i =~ m/^(vnl|vil|vsl|vul|vpl|vgl|vbl)_fwd$/ || $i =~ m/^vgui_glu?x?t?$/ || $i eq "StdAfx");
    next if ($i =~ m/^(v.l)_io_/ && $f =~ m/\/$1\/io\//);
    next if ($i =~ m/^accessors\/vipl_accessors_/ && $f =~ m/\/v[ie]pl\//);
    next if ($f =~ m/vbl\/io\/vbl_io_sparse_array_[123]d\.h$/ && $i =~ m/^vbl_sparse_array_[123]d$/);
    next if ($f =~ m/vgui\/impl\/gtk\/(vgui_gtk_adaptor\.h|Templates\/vcl_vector\+GtkWidget\~-\.cxx)$/ && $i eq "vcl_string");
    $i =~ s/^(vgui.*)/$1\(\|_sptr\|_new\)/;
    $i =~ s/^(v[st]ol.*)/$1\(\|_sptr\)/ unless ($f =~ m/\.h$/);
    if ($j eq "vcl_complex.h" && $f =~ m/\/tests\/test_vcl_cmath\.cxx$/) { $i=""; }
    if ($j eq "vcl_map.h") { $i="vcl_(multi)?map"; }
    if ($j eq "vcl_queue.h") { $i="vcl_(priority_)?queue"; }
    if ($j eq "vcl_string.h") { $i="vcl_(basic_)?string"; }
    if ($j eq "vcl_cerrno.h") { $i="(errno|EBUSY|EEXIST)"; }
    next if ($j eq "vcl_iostream.h" && $f =~ m!/(vcl_ios\.h|win32/vcl_complex\.h|StdAfx\.h)$!);
    if ($j eq "vcl_iostream.h") { $i="(vcl_(cout|cerr|cin|endl|[io]stream)|vgui_macro_warning)"; }
    if ($j eq "mbl/mbl_cloneable_ptr.h") { $i="($i|MBL_CLONEABLE_PTR_INSTANTIATE)"; }
    if ($j eq "mbl/mbl_gamma.h") { $i="mbl_(gamma_[pq]|erf)"; }
    if ($j eq "mbl/mbl_matrix_products.h") { $i="mbl_matrix_product(|_a_bt|_at_b|_adb)"; }
    if ($j eq "mbl/mbl_matxvec.h") { $i="($i)_(prod|add)_[a-z_]+"; }
    if ($j eq "mil/mil_bilin_interp_2d.h") { $i="mil(_safe(_extend)?)?_bilin_interp_2d"; }
    if ($j eq "mil/mil_convert_vil.h") { $i="($i)_[gc][mv]2[gc][mv]"; }
    if ($j eq "vbl/vbl_basic_optional.h") { $i="$i(|_traits)"; }
    if ($j eq "vbl/vbl_br_default.h") { $i="$i(|_iter|_wild_iter|_factory)"; }
    if ($j eq "vbl/vbl_qsort.h") { $i="($i)_[a-z_]+"; }
    if ($j eq "vbl/vbl_sort.h") { $i="($i)_[a-z_]+"; }
    if ($j eq "vepl/vepl_monadic.h") { $i="$i(|_[a-z_]+)"; }
    if ($j eq "vepl/vepl_dyadic.h") { $i="$i(|_[a-z_]+)"; }
    if ($j eq "vgl/vgl_clip.h") { $i="$i(|_[a-z_]+)"; }
    if ($j eq "vgl/vgl_distance.h") { $i="$i(2)?(|[a-z_]+)"; }
    if ($j eq "vgl/vgl_triangle_test.h") { $i="$i(|_[a-z_]+)"; }
    if ($j eq "vgui/vgui_adaptor.h") { $i="(vgui|get)_(adaptor|event)"; }
    if ($j eq "vgui/vgui_color_text.h") { $i="(text_to_color|(red|green|blue)_value)"; }
    if ($j eq "vgui/vgui_command.h") { $i="($i(|_[a-z_]+)|VGUI_COMMAND_SIMPLE_INSTANTIATE)"; }
    if ($j eq "vgui/vgui_find.h") { $i="($i)_[a-z_]+name"; }
    if ($j eq "vgui/vgui_macro.h") { $i="$i(|_[a-z_]+)"; }
    if ($j eq "vgui/vgui_menu.h") { $i="$i(_item)?"; }
    if ($j eq "vgui/vgui_pixel.h") { $i="($i)_([rgba1568]*|rgbfloat)"; }
    if ($j eq "vgui/vgui_rubberbander.h") { $i="$i((_easy2D)?_client)?"; }
    if ($j eq "vgui/vgui_soview2D.h") { $i="$i(|_point|_circle|_lineseg|_linestrip|_polygon|_group)"; }
    if ($j eq "vgui/vgui_statusbar.h") { $i="($i|get_statusbar\\(\\)->)"; }
    if ($j eq "vgui/vgui_tag.h") { $i="$i(|_[a-z_]+)"; }
    if ($j eq "vgui/vgui_tableau_sptr.h") { $i="($i(|_t)|get_tableau)"; }
    if ($j eq "vgui/internals/vgui_simple_field.h") { $i="vgui_(simple|bool|int|long|float|double)_field"; }
    if ($j eq "vil/vil_16bit.h") { $i="($i)_(read|write)_(big|little)_endian"; }
    if ($j eq "vil/vil_32bit.h") { $i="($i)_(read|write)_(big|little)_endian"; }
    if ($j eq "vil/vil_clamp.h") { $i="$i(|_pixel)"; }
    if ($j eq "vil/vil_convolve.h") { $i="$i(|_[a-z_]+)"; }
    if ($j eq "vil/vil_colour_space.h") { $i="($i)_(RGB|HSV)_to_(YIQ|HSV|RGB)"; }
    if ($j eq "vil/vil_image_as.h") { $i="$i(_[a-z16_]+)?"; }
    if ($j eq "vil/vil_interpolate.h") { $i="$i(|_[a-z_]+)"; }
    if ($j eq "vil/vil_warp.h") { $i="$i(|_mapping|_interpolation_type|_output_driven)"; }
    if ($j eq "vil/vil_jpeglib.h") { $i="jpeg_[a-z_]+"; }
    if ($j eq "vil/vil_memory_image.h") { $i="$i(|_format)"; }
    if ($j eq "vil/vil_pixel.h") { $i="($i)_format(|_t)"; }
    if ($j eq "vil/vil_property.h") { $i="$i(|_[a-z_]+)"; }
    if ($j eq "vil/vil_smooth.h") { $i="($i)_(gaussian|byte_separable_symmetric)"; }
    if ($j =~ m/vil\/file_formats\/(.*).h/) { $i="$1_file_format"; }
    if ($j eq "vipl/filter/vipl_filter_abs.h") { $i="($i|FILTER_IMPTR_(INC|DEC)_REFCOUNT)"; }
    if ($j =~ m/vipl\/vipl_with_vbl_array_2d\/accessors\/vipl_accessors_(vbl_array_2d)\.h/) { $i="$1"; }
    if ($j eq "vnl/algo/vnl_algo_fwd.h") { $i="vnl_(svd|qr|matrix_inverse|symmetric_eigensystem|cholesky|complex_eigensystem|conjugate_gradient|cpoly_roots|lbfgs|levenberg_marquardt)"; }
    if ($j eq "vnl/algo/vnl_chi_squared.h") { $i="($i)_[a-z]+"; }
    if ($j eq "vnl/algo/vnl_fft.h") { $i="$i(|_(|set)gpfa)"; }
    if ($j eq "vnl/algo/vnl_netlib.h") { $i="(zgeev|rpoly)_"; }
    if ($j eq "vnl/algo/vnl_symmetric_eigensystem.h") { $i="$i(|_compute)"; }
    if ($j eq "vnl/vnl_complex.h") { $i="vcl_complex"; }
    if ($j eq "vnl/vnl_error.h") { $i="$i(|_[a-z_]+)"; }
    if ($j eq "vnl/vnl_finite.h") { $i="($i)_int(|_poly)"; }
    if ($j eq "vnl/vnl_math.h") { $i="vnl_(math(|_[a-z_]+)|huge_val)"; }
    if ($j eq "vnl/vnl_matlab_print.h") { $i="($i|MATLABPRINT)"; }
    if ($j eq "vnl/vnl_sparse_matrix.h") { $i="$i(|_pair)"; }
    if ($j eq "vnl/vnl_T_n.h") { $i="($i)_[a-z_]*"; }
    if ($j eq "vnl/vnl_sample.h") { $i="$i(|_[a-z_]+)"; }
    if ($j eq "vnl/vnl_tag.h") { $i="($i)_[a-z]+"; }
    if ($j eq "vpl/vpl.h") { $i="($i)_[a-z]+"; }
    if ($j =~ m/(vsl\/vsl_[a-z]+_io|v[bginu]l\/io\/v[bginu]l_io_[a-z123_]+).h/) { $i="vsl_(b_(read|write)|print_summary)"; }
    if ($f =~ m/\/(v.l_io_test_all|io\/tests\/test_includes|tests\/test_vcl_headers)\.cxx$/) { $i=""; }
    if ($j eq "vsl/vsl_binary_io.h") { $i="vsl_b_(read|write|[io]f?stream)"; }
    if ($j eq "vsl/vsl_binary_loader.h") { $i="($i|vsl_b_(read|write))"; }
    next if ($j eq "vsl/vsl_binary_loader.h" && $f =~ m/\/Templates\/\S+\~-\.cxx$/);
    if ($j eq "vsl/vsl_binary_explicit_io.h") { $i="vsl_(convert_[a-z_]+|swap_bytes|swap_bytes_to_buffer|b_(read|write)_[a-z_]+)"; }
    if ($j eq "vsl/vsl_complex_io.h") { $i="(VNL_IO_[A-Z]+_INSTANTIATE.vcl_complex|vsl_b_(read|write))"; }
    if ($j eq "vsl/vsl_indent.h") { $i="$i(|_inc|_dec|_set_tab|_tab|_clear)"; }
    next if ($j eq "vsol/vsol_curve.h" && $f =~ m!Templates/vbl_smart_ptr\+vtol_edge-\.cxx$!);
    next if ($j eq "vsol/vsol_point.h" && $f =~ m!Templates/vbl_smart_ptr\+vtol_edge-\.cxx$!);
    next if ($j eq "vsol/vsol_region.h" && $f =~ m!Templates/vbl_smart_ptr\+vtol_face-\.cxx$!);
    next if ($j eq "vsol/vsol_curve_2d.h" && $f =~ m!Templates/vbl_smart_ptr\+vtol_edge_2d-\.cxx$!);
    next if ($j eq "vsol/vsol_point_2d.h" && $f =~ m!Templates/vbl_smart_ptr\+vtol_edge_2d-\.cxx$!);
    next if ($j eq "vsol/vsol_region_2d.h" && $f =~ m!Templates/vbl_smart_ptr\+vtol_face_2d-\.cxx$!);
    if ($j eq "vtol/vtol_dtd.h") { $i="$i([0123])"; }
    if ($j eq "vtol/vtol_list_functions.h") { $i="(tagged_union|(SEL|COPY)_(SUP|INF))"; }
    if ($j eq "vtol/vtol_macros.h") { $i="(SEL|COPY)_(SUP|INF)"; }
    if ($j eq "vul/vul_arg.h") { $i="$i(|_parse|_include|_display_usage_and_exit|_info_list)"; }
    if ($j eq "vul/vul_string.h") { $i="$i(|_[a-z_]+)"; }
    if ($i =~ m/^(v.l_test)$/) { $i="(TEST|$1_(start|assert|assert_near|perform))"; }
    print "$f\t\# should not have #include <$j>\n"
      unless $file =~ m/$j\>[^\003]*\b$i\b/ || $f =~ m/\/$i\./;
  }
  print "$f\t\# should have #include <vcl_cassert.h>\n"
    if (! $found_cassert && $file =~ m/\n\s*assert\s*\(/);

# 6. //: inside a comment block, or \file not after //:
  if ($file =~ m!\n\s*//[^:][^\n]*\n *// *\\file\b! ||
      $file =~ m!\n\s*[^\s/][^\n]*\n *// *\\file\b!) {
    print "$f\t\# \\file is not preceeded by //:\n";
    $printed = 1;
  }
  $file =~ s!//\s*[-=_]{40,}\n!//\n!g;
  if ($file =~ m!\n\s*//[ :][^\n]*\n *//:!) {
    print "$f\t\# contains //: inside a comment block\n";
    $printed = 1;
  }

# 7. Comments: long /* ... */ and old-style // -- docs
  $file =~ s/ +\n/\n/g;
  $file =~ s/\/\*/\001/g; $file =~ s/\/\001/\/\/\*/g;
  $file =~ s/\*\//\002/g;
  $file =~ s/(\"[^\001\n\"]{0,15})\001([^\001\n\"]{0,15}\")/$1\/\*$2/g;
  $file =~ s/(\"[^\002\n\"]{0,15})\002([^\002\n\"]{0,15}\")/$1\*\/$2/g;
  $file =~ s/\001\*/\/\*\*/g; # Doxygen style comments
  if ($file =~ m/\/\/\s*[a-zA-Z_0_9]*\s*--\s/) {
    print "$f\t\# contains old style // -- docs\n";
    $printed = 1;
  }
  if ($f !~ m/\.c$/ &&
      $f !~ m/_mocced\.cxx$/ &&
      $f !~ m/\bv3p\/(netlib|[jm]peg|tiff|png|zlib|Qv)\// &&
      $f !~ m/\bfile_formats\/vil_viff(header|_support)/ &&
      $f !~ m/\bvgui\/internals\/trackball/ &&
      $f !~ m/\bvxl\/vgl\/internals\/gpc.h$/ &&
      $f !~ m/\/oufgl\/(pxc200|bt848(-addons)?)\.h$/ &&
      $f !~ m/\bgel\/vgel\/kl\/.*\.h$/ &&
      $f !~ m/\bvcl\/vcl_c/ &&
      $f !~ m/\bvcl\/emulation\// &&
      $file =~ m/\001[^\001\002]{111,}/)
  {
    print "$f\t\# contains long /*...*/ comments\n";
    $printed = 1;
  }
  if ($file =~ m/^\s*\/\/\s*vcl_c(out|err)\s*\<\<[^\n]*(\n\s*\/\/[^\n]*){5,}/) {
    print "$f\t\# consider commenting out code sections with #if 0 or #ifdef DEBUG\n";
    $printed = 1;
  }

# 8. RCS indications
  if ($file =~ m/(\$RCSfile)/) {
    print "$f\t\# contains RCS indication $1\n";
    $printed = 1;
  }

# 9. Now remove comments and string constants before checking further:
  $file_s = "\n" . $file;
  $file_s =~ s/\n\#if\s+0\s*\n.*?\n\#endif\s*\n/\n/g;
  # remove string constants, incl. multiline string constants with "correct syntax":
  $file_s =~ s/\\\n//g; $file_s =~ s/([^\\])(\\\")+/$1/g;
  $file_s =~ s/\".*?\"/\003/g;
  # replace :: by \005 and -> by \006 (useful later)
  $file_s =~ s/::/\005/g;
  $file_s =~ s/->/\006/g;
  # remove // comments
  $file_s =~ s/\/\/[^\n]*\n/\n/g;
  # remove /* ... */ comments
  $file_s =~ s/(\001|\/\*)[^\001\002]*\002//g;
# if ($file_s =~ m/[\001\002]/) {
#   print "$f\t\# contains nested comments\n";
#   $printed = 1;
# }
# continuation lines:
  $file_s =~ s/\\\n//g;

# 10. Multi-line string constant
  if ($file_s =~ m/\"/) {
    print "$f\t\# contains multi-line string constant\n";
    $printed = 1;
  }
# 11. Inclusion guard
  if ($file_s =~ m/^\s*\#ifndef\s+(\S+)\s*\n#define\s+\1\s*(\s[^\n]*)?\n/) {
    $guard = $1;
    if (defined($inclusion_guards{"$guard"})) {
      print "$f\t\# has the same inclusion guard as " . $inclusion_guards{"$guard"} . "\n";
      $printed = 1;
    }
    else {
      $inclusion_guards{"$guard"} = "$f";
    }
    undef $guard;
  }
  else {
    unless ($f !~ m/\.(txx|h)$/ ||
            $f =~ m/vcl\/emulation\/.*stlco(nf|mp)\.h$/ ||
            $f =~ m/vcl\/vcl_typeinfo\.h$/ ||
            $f =~ m/v3p\/(netlib|[jm]peg|tiff|png|zlib)\// ||
            $f =~ m/\/resource\.h$/i ||
            $f =~ m/vcl(\/win32)?\/vcl_c(assert|string)/ ||
            $file_s eq "\n")
    {
      print "$f\t\# has no (valid) inclusion guard\n";
      $printed = 1;
    }
  }

# 12. Constant pi written as 3.1415...
  if ($f !~ m/\b(v[cuib]l|v3p)\// && $f !~ m/\bvxl\/vnl\/vnl_math\./ && $f !~ m/\.c$/ &&
      $file_s =~ m/\b(3\.14159\d*)/) {
    print "$f\t\# should maybe use vnl_math::pi instead of $1\n";
    $printed = 1;
  }

# 13. Instantiation macro stuff
  if ($file_s =~ m/\#define\s+(\S*INSTANTIATE[^\s\(\)]*)[^\n]+;\s*\n/) {
    print "$f\t\# definition of $1 ends with ;\n";
    $printed = 1;
  }
  if ($file_s =~ m/\#define\s+(\S*INSTANTIATE[^\s\(\)]*)\s*\([^)]*\)\S/) {
    print "$f\t\# definition of $1 does not start with a space\n";
    $printed = 1;
  }
  if ($file_s =~ m/\#define\s+(\S*INSTANTIATE[^\s\(\)]*)[^\n]+(\<[^<>\n]*[A-Za-z_][A-Za-z_0-9]*\>)/) {
    print "$f\t\# definition of $1 has no space before > in $2\n";
    $printed = 1;
  }
# Presence of VCL_*_INSTANTIATE in *.cxx files outside Templates directories
  if ($f !~ m!/Templates/! &&
      $f !~ m!vcl/tests/test_vcl_rel_ops\.cxx$! &&
      $f !~ m!vxl/vsl/tests/test_polymorphic_io\.cxx$! &&
      $f !~ m!oxl/vgui/examples/awf/glmovie\.cxx$! &&
      $f !~ m!oxl/apps/glmovie/glmovie.cxx$! &&
      $file_s =~ m+\n\s*(VCL_[_A-Z]*INSTANTIATE[_A-Z]*)+ &&
      "$1" ne "VCL_INSTANTIATE_INLINE") {
    print "$f\t\# $1 may only be used in Templates subdirectories\n";
    $printed = 1;
  }
# Check correct file name of *.cxx files in Templates directories
  $file_s =~ s/VCL_DO_NOT_INSTANTIATE/VCL_do_not_INSTANTIATE/g;
  if ($f =~ m!/Templates/! &&
      $f !~ m!vcl/Templates/(complex|string)-instances\.cxx$! &&
      $f !~ m!vxl/vnl/algo/Templates/fsm_pack\.cxx$! &&
      $f !~ m!vxl/vbl/examples/Templates/smartptr-instances\.cxx$! &&
      $f !~ m!vxl/vnl/Templates/vnl_matrix_fixed_pairwise_ops\.cxx$! &&
      $file_s =~ m/\b([_A-Z0-9]*)_INSTANTIATE\s*\((.*)\)/) {
    $class=$1; $class =~ tr/A-Z/a-z/; $class="$class<$2>";
    $class =~ s/\bvcl_swap\s*\</vcl_algorithm\</g;
    $class =~ s/\bvcl_sort\s*\<[^,]+\,/vcl_algorithm\</g;
    $class =~ s/\bvcl_find_if\s*\<\s*vcl_vector\s*\<([^\005]+)\005\s*iterator.+/vcl_algorithm\<$1/g;
    while ($file_s =~ m/\btypedef\s+([^;]*)\s(\S+)\s*\;/)
    { $A=$1; $B=$2; $B =~ s/([][{}()|*+\/\\])/\\$1/g; $class =~ s/\b$B\b/$A/g; $file_s =~ s/\btypedef\s[^;]*\;//; }
#   $class =~ s/\bconst\b//g;
    $class =~ s/\s//g;
    $class =~ s/\bconstchar/const_char/g; $class =~ s/(\w)const/$1_const/g;
    $class =~ s/\,vcl_less\<[^<>]+\<[^<>]+\>[^<>]*\>//g;
    $class =~ s/\,vcl_less\<[^<>]+\>//g;
    $class =~ s/(vbl_io_sparse_array)_base\</$1\</g;
    $class =~ s/\005/+-/g; $class =~ tr/<,*>/+.~-/; # \005 is ::
    $class_q = $class; $class_q =~ s/([.+~-])/\\$1/g;
    $class =~ s/unsigned/u/g; $class =~ s/signed/s/g; $class =~ s/longd/long_d/g;
    $class_r = $class; $class_r =~ s/([.+~-])/\\$1/g;
    $class_s = $class_q; $class_s =~ s/signed/signed_/g; $class_s =~ s/long/long_/g;
    if ($f !~ m/\/$class_q\.(cxx|cc|C)$/ &&
        $f !~ m/\/$class_r\.(cxx|cc|C)$/ &&
        $f !~ m/\/$class_s\.(cxx|cc|C)$/) {
      print "$f\t\# should be renamed to $class.cxx\n";
      $printed = 1;
    }
  }

# 14. Missing vcl_
  foreach $wd (split(' ',"abort exit")) {
    if ($f !~ m/\.c$/ && $f !~ m/\bv3p\/(netlib|[jm]peg|tiff|png|zlib)\// &&
        "$f.$wd" !~ m/\bvcl\/tests\/test_vcl_exception\.cxx\.abort$/ &&
        $file_s =~ m/\b$wd\s*(\s*)\(/) {
      print "$f\t\# $wd$1() must be vcl_$wd()\n";
      $printed = 1;
    }
  }
  foreach $wd (split(' ',"complex real imag conj arg polar abs acos asin atan atan2 ceil cos exp fabs floor log min max pow sin sqrt printf fprintf sprintf scanf fscanf sscanf fopen fclose fread fwrite memchr memcpy memcmp memmove memset strcat strncat strcpy strncpy strchr strcmp strncmp strcoll strcspn strerror strlen strpbrk strrchr strspn strstr strtok strxfrm isspace isprint iscntrl isupper islower isalpha isgraph isdigit ispunct isxdigit isalnum isgraph toupper tolower")) {
    if ($f !~ m/\.c$/ && $f !~ m/\bv3p\/(netlib|[jm]peg|tiff|png|zlib)\// && $f !~ m/\bv3p\/Qv\/vectors\.h$/ &&
        $f !~ m/\/oufgl\/pxc200\.h$/ && $f !~ m/\bvcl(\/[^\/]+)?\/vcl_(cmath|complex|cstdlib|sstream)\./ &&
        "$f.$wd" !~ m/\/emulation\/[^\/]*-stlconf\.h\.f?printf$/ &&
        "$f.$wd" !~ m/vnl_(rational|bignum)\.(h|cxx)\.sqrt$/ &&
        "$f.$wd" !~ m/\bvul\/vul_timer\.(h|cxx)\.real$/ &&
        "$f.$wd" !~ m/\bvnl\/vnl_quaternion\.h\.real$/ &&
        "$f.$wd" !~ m/\bvnl\/tests\/test_complex\.cxx\.acos$/ &&
        "$f.$wd" !~ m/\bvnl\/(vnl_rational\.h|tests\/test_rational\.cxx)\.(abs|ceil|floor)$/ &&
        "$f.$wd" !~ m/\b(vnl\/vnl_bignum\.h|mbl\/mbl_arb_length_int\.h)\.abs$/ &&
        "$f.$wd" !~ m/\bvnl\/vnl_numeric_limits\.h\.(min|max)$/ &&
        "$f.$wd" !~ m/\bvnl\/vnl_finite\.h\.(exp|log|pow)$/ &&
        "$f.$wd" !~ m/\bvil\/vil_rgb\.(h|txx)\.(min|max)$/ &&
        "$f.$wd" !~ m/\bvbl\/vbl_bounding_box\.(h|txx)\.(min|max)$/ &&
        "$f.$wd" !~ m/\bgel\/vgel\/kl\/base\.h\.(min|max)$/ &&
        "$f.$wd" !~ m/\bmul\/mbl\/mbl_stats_1d\.h\.(min|max)$/ &&
        "$f.$wd" !~ m/\boxl\/mvl\/HomgConic\.(h|cxx)\.polar$/ &&
        "$f.$wd" !~ m/\bvnl\/algo\/vnl_rn?poly_(solve|roots)\.h\.(real|imag)$/ &&
        $file_s =~ m/[^.\005\006]\b$wd(\s*)\(/) { # \005 is :: and \006 is ->
      print "$f\t\# $wd$1() must be vcl_$wd()\n";
      $printed = 1;
    }
  }
  foreach $wd (split(' ',"cin cout cerr clog endl ends flush ios istream ostream fstream ifstream ofstream strstream ostrstream streambuf streamoff streamsize fpos streampos stringstream")) {
    if ($f !~ m/\.c$/ && $f !~ m/\bv3p\/(netlib|[jm]peg|tiff|png|zlib)\// &&
        $f !~ m/\bvcl\/.*\bvcl_(ios|iosfwd|iomanip|[siof]+stream|strstream|streambuf)\.h/ &&
        $f !~ m/\bvcl\/Templates\/stream-instances\.cxx$/ &&
        $file_s =~ m/[^ .]\s*\b$wd\b\s*[^ (]/) {
      print "$f\t\# $wd must be vcl_$wd\n";
      $printed = 1;
    }
  }
  foreach $wd (split(' ',"basefield floatfield adjustfield fmtflags seekdir")) {
    if ($f !~ m/\.c$/ && $f !~ m/\bv3p\/(netlib|[jm]peg|tiff|png|zlib)\// &&
        $f !~ m/\bvcl\/.*\bvcl_(ios|iosfwd|iomanip|[siof]+stream|strstream|streambuf)\.h/ &&
        $file_s =~ m/[^ .]\s*\b$wd\b\s*[^ (]/) {
      print "$f\t\# $wd must be vcl_ios_$wd\n";
      $printed = 1;
    }
  }
  foreach $wd (split(' ',"beg cur end")) {
    if ($f !~ m/\.c$/ && $f !~ m/\bv3p\/(netlib|[jm]peg|tiff|png|zlib)\// &&
        $f !~ m/\bvcl\/.*\bvcl_(ios|iosfwd|iomanip|[siof]+stream|strstream|streambuf)\.h/ &&
        ($f !~ m/\bvcl\/emulation\/vcl_string\.h$/ || $wd !~ m/end/ ) &&
        ($f !~ m/\boxp\/oxp_mpeg_codec\.cxx$/ || $wd !~ m/end/ ) &&
        ($f !~ m/\b(rrel\/rrel_util|rsdl\/rsdl_borgefors)\.txx$/ || $wd !~ m/end/ ) &&
        $file_s =~ m/,\s*$wd\s*\)/) {
      print "$f\t\# $wd must be vcl_ios_$wd\n";
      $printed = 1;
    }
  }
  foreach $wd (split(' ',"boolalpha noboolalpha showbase noshowbase showpoint noshowpoint showpos noshowpos skipws noskipws uppercase nouppercase")) {
    if ($f !~ m/\.c$/ && $f !~ m/\bv3p\/(netlib|[jm]peg|tiff|png|zlib)\// &&
        $f !~ m/\bvcl\/.*\bvcl_(ios|iosfwd|iomanip|[siof]+stream|strstream|streambuf)\.h/ &&
        $file_s =~ m/[^ .]\s*\b$wd\b\s*[^ (]/) {
      print "$f\t\# $wd must be vcl_ios_$wd\n";
      $printed = 1;
    }
    if ($f !~ m/\bvcl\/.*\bvcl_(ios|iosfwd|iomanip|[siof]+stream|strstream|streambuf)\.h/ &&
        $file_s =~ m/\b$wd\s*\(/) {
      print "$f\t\# $wd() must be vcl_$wd()\n";
      $printed = 1;
    }
  }
  foreach $wd (split(' ',"internal left right")) {
    if ($f !~ m/\.c$/ && $f !~ m/\bv3p\/(netlib|[jm]peg|tiff|png|zlib)\// &&
        $f !~ m/\bvcl\/.*\bvcl_(ios|iosfwd|iomanip|[siof]+stream|strstream|streambuf)\.h/ &&
        ($f !~ m/\bvcl\/emulation\/vcl_(algorithm|tree).h$/ || $wd !~ m/(left|right)/ ) &&
        ($f !~ m/\bvnl\/(vnl_matrix\.txx|algo\/vnl_complex_eigensystem\.cxx)$/ || $wd !~ m/(left|right)/ ) &&
        ($f !~ m/\bpdf1d\/pdf1d_pdf\.cxx$/ || $wd !~ m/(left|right)/ ) &&
        ($f !~ m/\b(oxl\/oxp\/vsl_conic_points\.cxx|gel\/gevd\/gevd_float_operators\.cxx)$/ || $wd !~ m/(left|right)/ ) &&
        ($f !~ m/\bvcsl\/examples\/vcsl_tutor\.cxx$/ || $wd !~ m/right/ ) &&
        ($f !~ m/\brsdl\/rsdl_(bins_2d|kd_tree)\.h$/ || $wd !~ m/right/ ) &&
        ($f !~ m/\brsdl\/(rsdl_kd_tree|tests\/test_rsdl_bins_2d|tests\/test_rsdl_kd_tree)\.cxx$/ || $wd !~ m/(left|right)/ ) &&
        $file_s =~ m/[^ .>]\s*\b$wd\s*[|),]/) {
      print "$f\t\# $wd must be vcl_ios_$wd\n";
      $printed = 1;
    }
    if ($f !~ m/\bvcl\/.*\bvcl_(ios|iosfwd|iomanip|[siof]+stream|strstream|streambuf)\.h/ &&
        $file_s =~ m/\bvcl_ios_$wd\s*[^ ,]/ &&
        $file_s !~ m/(vcl_resetiosflags|\.\s*unsetf)\s*\((vcl_ios_(internal|left|right)\s*\|\s*)*vcl_ios_$wd\s*(\|\s*vcl_ios_(internal|left|right)\s*)*\)/) {
      print "$f\t\# vcl_ios_$wd must be used together with vcl_ios_adjustfield\n";
      $printed = 1;
    }
    if ($f !~ m/\bvcl\/.*\bvcl_(ios|iosfwd|iomanip|[siof]+stream|strstream|streambuf)\.h/ &&
        ($f !~ m/\bvcl\/emulation\/vcl_tree\.h$/ || $wd !~ m/^(left|right)$/) &&
        ($f !~ m/\boxl\/oxp\/vsl_conic_points\.cxx$/ || $wd !~ m/(left|right)/ ) &&
        $file_s =~ m/\b$wd\s*\(/) {
      print "$f\t\# $wd() must be vcl_$wd()\n";
      $printed = 1;
    }
  }
  foreach $wd (split(' ',"dec hex oct")) {
    if ($f !~ m/\.c$/ && $f !~ m/\bv3p\/(netlib|[jm]peg|tiff|png|zlib)\// &&
        $f !~ m/\bvcl\/.*\bvcl_(ios|iosfwd|iomanip|[siof]+stream|strstream|streambuf)\.h/ &&
        $file_s =~ m/\b$wd\s*[|),]/) {
      print "$f\t\# $wd must be vcl_ios_$wd\n";
      $printed = 1;
    }
    if ($f !~ m/\bvcl\/.*\bvcl_(ios|iosfwd|iomanip|[siof]+stream|strstream|streambuf)\.h/ &&
        $file_s =~ m/\bvcl_ios_$wd\s*[^ ,]/ &&
        $file_s !~ m/(vcl_resetiosflags|\.\s*unsetf)\s*\((vcl_ios_(dec|hex|oct)\s*\|\s*)*vcl_ios_$wd\s*(\|\s*vcl_ios_(dec|hex|oct)\s*)*\)/) {
      print "$f\t\# vcl_ios_$wd must be used together with vcl_ios_basefield\n";
      $printed = 1;
    }
    if ($f !~ m/\bvcl\/.*\bvcl_(ios|iosfwd|iomanip|[siof]+stream|strstream|streambuf)\.h/ &&
        $file_s =~ m/\b$wd\s*\(/) {
      print "$f\t\# $wd() must be vcl_$wd()\n";
      $printed = 1;
    }
  }
  foreach $wd (split(' ',"scientific fixed")) {
    if ($f !~ m/\.c$/ && $f !~ m/\bv3p\/(netlib|[jm]peg|tiff|png|zlib)\// &&
        $f !~ m/\bvcl\/.*\bvcl_(ios|iosfwd|iomanip|[siof]+stream|strstream|streambuf)\.h/ &&
        ($f !~ m/\bvpdfl\/vpdfl_pc_gaussian_builder\./ || $wd !~ m/^fixed$/) &&
        $file_s =~ m/\b$wd\s*[|),]/) {
      print "$f\t\# $wd must be vcl_ios_$wd\n";
      $printed = 1;
    }
    if ($f !~ m/\bvcl\/.*\bvcl_(ios|iosfwd|iomanip|[siof]+stream|strstream|streambuf)\.h/ &&
        $file_s =~ m/\bvcl_ios_$wd\s*[^ ,]/ &&
        ($f !~ m/\bvpdfl\/vpdfl_pc_gaussian_builder\./ || $wd !~ m/^fixed$/) &&
        $file_s !~ m/(vcl_resetiosflags|\.\s*unsetf)\s*\((vcl_ios_(scientific|fixed)\s*\|\s*)*vcl_ios_$wd\s*(\|\s*vcl_ios_(scientific|fixed)\s*)*\)/) {
      print "$f\t\# vcl_ios_$wd must be used together with vcl_ios_floatfield\n";
      $printed = 1;
    }
    if ($f !~ m/\.c$/ && $f !~ m/\bv3p\/(netlib|[jm]peg|tiff|png|zlib)\// &&
        $f !~ m/\bvcl\/.*\bvcl_(ios|iosfwd|iomanip|[siof]+stream|strstream|streambuf)\.h/ &&
        $file_s =~ m/\b$wd\s*\(/) {
      print "$f\t\# $wd() must be vcl_$wd()\n";
      $printed = 1;
    }
  }
  foreach $wd (split(' ',"size_t ptrdiff_t clock_t time_t")) {
    if ($f !~ m/\.c$/ && $f !~ m/\bv3p\/(netlib|[jm]peg|tiff|png|zlib)\// &&
        $f !~ m/\bvcl\/.*\bvcl_c(stddef|stdio|time)\./ &&
        $file_s =~ m/\b$wd\b/) {
      print "$f\t\# $wd must be vcl_$wd\n";
      $printed = 1;
    }
  }
  foreach $wd (split(' ',"iterator_traits back_insert_iterator front_insert_iterator insert_iterator input_iterator_tag output_iterator_tag forward_iterator_tag bidirectional_iterator_tag random_access_iterator_tag")) {
    if ($f !~ m/\.c$/ && $f !~ m/\bv3p\/(netlib|[jm]peg|tiff|png|zlib)\// &&
        $f !~ m/\bvcl\/.*\bvcl_iterator\.(h|txx)$/ &&
        $file_s =~ m/\b$wd\b/) {
      print "$f\t\# $wd must be vcl_$wd\n";
      $printed = 1;
    }
  }

# 15. Multiple empty lines, empty line before } or after {, return (...),
#   if/for/while without space, variable name starting with underscore
#   (mentioned only if something else is already printed, or is -f given)
  print "$f\t\# contains multiple (>2) empty lines\n"
    if ($printed && $file =~ m/\n\n\n\n/);
  print "$f\t\# has lines ending in spaces\n"
    if ($printed && $has_end_spaces);
  print "$f\t\# has empty lines before closing brace\n"
    if ($printed && $file =~ m/\n\n[ \t]*\};*\s*\n/);
  print "$f\t\# has empty lines after opening brace\n"
    if ($printed && $file =~ m/\n[ \t]*\{\s*\n\n/);
  print "$f\t\# $1 not followed by space\n"
    if ($printed && $file =~ m/\b(for|if|while)\(/);
  print "$f\t\# return value in brackets\n"
    if ($printed && $file =~ m/\breturn\s*\([^;()]*(\([^;()]*\)[^;()]*)*\)\s*;/);
  print "$f\t\# delete value in brackets\n"
    if ($printed && $file =~ m/\bdelete\s*\([^;()]*(\([^;()]*\)[^;()]*)*\)\s*;/);
  $file =~ s/^\#[^\n]*//g; $file =~ s/\n\#[^\n]*//g;
  print "$f\t\# $1 starts with underscore\n"
    if ($printed && $file =~ m/[^#]\b(_[a-z][a-zA-Z0-9_]*)/);

# 16. no end-of-line at end-of-file
  $file =~ s/[^\n]*\n//g;
  unless ($file eq "") {
    print "$f\t\# has no final end-of-line\n";
  }
}
