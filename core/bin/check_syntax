#! /bin/sh
exec perl -w -x $0 ${1+"$@"}
#!perl
#line 5

# Purpose: list all files in the vxl source tree that have tab characters
# (and that shouldn't have them because vxl c++ source files shouldn't).

undef $/;
$full = "";

while (defined($ARGV[0]) && $ARGV[0] =~ m/^-/) {
  $_ = shift(@ARGV);
  if (m/^-f$/) {
    $full = 1;
  }
  else {
    printf STDERR "Unrecognised command line option $_ ignored\n";
  }
}

if (defined($ARGV[0])) {
  @FILES = @ARGV;
}
else {
  $IUEROOT = $ENV{IUEROOT};
  unless (defined($IUEROOT)) {
    print STDERR "IUEROOT is not defined, and no command line arguments were given\n";
    exit 0;
  }
  $FILES = `find $IUEROOT/config $IUEROOT/vcl $IUEROOT/v3p $IUEROOT/vxl $IUEROOT/mul $IUEROOT/oxl $IUEROOT/gel $IUEROOT/tbl $IUEROOT/conversions -type f \\\( -name \\\*.cxx -name \\\*.txx -o -name \\\*.cc -o -name \\\*.cpp -o -name \\\*.c -o -name \\\*.h \\\) -print|grep -v /gel/v.ol\\.new/`;
  @FILES = split(' ', $FILES);
}

foreach $f (@FILES)
{
  unless (open(FILE, $f)) {
    print STDERR "File $f does not exist\n";
    next;
  }
  $file=<FILE>;
  close FILE;
  $printed = $full;

# 1. abnormal characters (tabs, ascii < 32, etc.)
  if ($file =~ m/[\000-\010\013-\037\177-\277\320\327\336\360\367\376]/) {
    print "$f\t\# has non-standard ascii characters\n";
    $printed = 1;
  }
  if ($file =~ m/\t/) {
    print "$f\t\# contains tabs\n";
    $printed = 1;
  }

# 2. spaces at end of line
  $has_end_spaces = ($file =~ m/ +\n/);

# 3. Lines longer than 132 characters
  if ($file =~ m/[^\n]{133,}/) {
    print "$f\t\# has lines of more than 132 characters\n";
    $printed = 1;
  }

# 4. Comments: long /* ... */ and old-style // -- docs
  $file =~ s/ +\n/\n/g;
  $file =~ s/\/\*/\001/g; $file =~ s/\/\001/\/\/\*/g;
  $file =~ s/\*\//\002/g;
  $file =~ s/(\"[^\001\n\"]{0,15})\001([^\001\n\"]{0,15}\")/$1\/\*$2/g;
  $file =~ s/(\"[^\002\n\"]{0,15})\002([^\002\n\"]{0,15}\")/$1\*\/$2/g;
  if ($file =~ m/\/\/\s*[a-zA-Z_0_9]*\s*--\s/) {
    print "$f\t\# contains old style // -- docs\n";
    $printed = 1;
  }
  if ($f !~ m/\.c$/ &&
      $f !~ m/_mocced\.cxx$/ &&
      $f !~ m/\bv3p\/(tiff|netlib|jpeg|png|zlib|Qv)\// &&
      $f !~ m/\bfile_formats\/vil_viff(header|_support)/ &&
      $f !~ m/\bvgui\/internals\/trackball/ &&
      $f !~ m/\bvcl\/vcl_c/ &&
      $f !~ m/\bvcl\/emulation\// &&
      $file =~ m/\001[^\001\002]{111,}/)
  {
    print "$f\t\# contains long /*...*/ comments\n";
    $printed = 1;
  }

# 5. RCS indications
  if ($file =~ m/(\$RCSfile)/) {
    print "$f\t\# contains RCS indication $1\n";
    $printed = 1;
  }

# 6. Now remove comments and string constants before checking further:
  $file_s = "\n" . $file;
  $file_s =~ s/\n\#if\s+0\s*\n.*?\n\#endif\s*\n/\n/g;
  # remove string constants, incl. multiline string constants with "correct syntax":
  $file_s =~ s/\\\n//g; $file_s =~ s/([^\\])\\\"/$1/g;
  $file_s =~ s/\".*?\"/\003/g;
  # replace :: by \005 and -> by \006 (useful later)
  $file_s =~ s/::/\005/g;
  $file_s =~ s/->/\006/g;
  # remove // comments
  $file_s =~ s/\/\/[^\n]*\n/\n/g;
  # remove /* ... */ comments
  $file_s =~ s/\001[^\001\002]*\002//g;
# if ($file_s =~ m/[\001\002]/) {
#   print "$f\t\# contains nested comments\n";
#   $printed = 1;
# }

# 7. Multi-line string constant
  if ($file_s =~ m/\"/) {
    print "$f\t\# contains multi-line string constant\n";
    $printed = 1;
  }
# 8. Inclusion guard
  if ($file_s =~ m/^\s*\#ifndef\s+(\S+)\n#define\s+\1\n/) {
    $guard = $1;
    if (defined($inclusion_guards{"$guard"})) {
      print "$f\t\# has the same inclusion guard as " . $inclusion_guards{"$guard"} . "\n";
      $printed = 1;
    }
    else {
      $inclusion_guards{"$guard"} = "$f";
    }
    undef $guard;
  }
  else {
    unless ($f !~ m/\.(txx|h)$/ ||
            $f =~ m/vcl\/emulation\/.*stlco(nf|mp)\.h$/ ||
            $f =~ m/vcl\/vcl_typeinfo\.h$/ ||
            $f =~ m/v3p\/(jpeg|tiff|zlib)\// ||
            $f =~ m/\/resource\.h$/i ||
            $f =~ m/vcl(\/win32)?\/vcl_c(assert|string)/ ||
            $file_s eq "\n")
    {
      print "$f\t\# has no (valid) inclusion guard\n";
      $printed = 1;
    }
  }

# 9. Constant pi written as 3.1415...
  if ($f !~ m/\b(v[cibt]l|v3p)\// && $f !~ m/\bvxl\/vnl\/vnl_math\./ && $f !~ m/\.c$/ &&
      $file_s =~ m/\b(3\.14159\d*)/) {
    print "$f\t\# should maybe use vnl_math::pi instead of $1\n";
    $printed = 1;
  }

# 9. Instantiation macro stuff
  if ($file_s =~ m/\#define\s+(\S*INSTANTIATE[^\s\(\)]*)[^\n]+;\s*\n/) {
    print "$f\t\# definition of $1 ends with ;\n";
    $printed = 1;
  }
  if ($file_s =~ m/\#define\s+(\S*INSTANTIATE[^\s\(\)]*)\s*\([^)]*\)\S/) {
    print "$f\t\# definition of $1 does not start with a space\n";
    $printed = 1;
  }
  if ($file_s =~ m/\#define\s+(\S*INSTANTIATE[^\s\(\)]*)[^\n]+(\<[^<>\n]*[A-Za-z_][A-Za-z_0-9]*\>)/) {
    print "$f\t\# definition of $1 has no space before > in $2\n";
    $printed = 1;
  }

# 10. Missing vcl_
  foreach $wd (split(' ',"abort exit")) {
    if ($f !~ m/\bv3p\/(netlib|jpeg|png|zlib)\// &&
        $f !~ m/\.c$/ &&
        $file_s =~ m/\b$wd\s*(\s*)\(/) {
      print "$f\t\# $wd$1() must be vcl_$wd()\n";
      $printed = 1;
    }
  }
  foreach $wd (split(' ',"complex real imag conj arg polar abs acos asin atan atan2 ceil cos exp fabs floor log min max pow sin sqrt")) {
    if ($f !~ m/\bvcl(\/[^\/]+)?\/vcl_(cmath|complex|cstdlib)\./ &&
        $f !~ m/\bv3p\/(netlib|tiff|png)\// && $f !~ m/\bv3p\/Qv\/vectors\.h$/ &&
        $f !~ m/\.c$/ &&
        $f !~ m/\bvnl\/vnl_complex_ops\.txx$/ &&
        "$f.$wd" !~ m/\bvbl\/vbl_timer\.(h|cxx)\.real$/ &&
        "$f.$wd" !~ m/\bvnl\/vnl_quaternion\.h\.real$/ &&
        "$f.$wd" !~ m/\bvnl\/vnl_numeric_limits\.h\.(min|max)$/ &&
        "$f.$wd" !~ m/\bvil\/vil_rgb\.(h|txx)\.(min|max)$/ &&
        "$f.$wd" !~ m/\boxl\/mvl\/HomgConic\.(h|cxx)\.polar$/ &&
        "$f.$wd" !~ m/\bvnl\/algo\/vnl_rn?poly_(solve|roots)\.h\.(real|imag)$/ &&
        $file_s =~ m/[^.\005\006]\b$wd\s*(\s*)\(/) { # \005 is :: and \006 is ->
      print "$f\t\# $wd$1() must be vcl_$wd()\n";
      $printed = 1;
    }
  }
  foreach $wd (split(' ',"cin cout cerr clog endl istream ostream fstream ifstream ofstream")) {
    if ($f !~ m/\bvcl(\/iso|\/generic|\/sgi)?\/vcl_(iosfwd|[iof]+stream)\.h/ &&
        $f !~ m/\bvcl\/Templates\/stream-instances\.cxx$/ &&
        $file_s =~ m/\b$wd\b/) {
      print "$f\t\# $wd must be vcl_$wd\n";
      $printed = 1;
    }
  }
  foreach $wd (split(' ',"size_t ptrdiff_t clock_t time_t")) {
    if ($f !~ m/\bvcl(\/generic|\/sgi|\/win32)?\/vcl_c(stddef|stdio|time)\./ &&
        $f !~ m/\bv3p\/(jpeg|tiff|png)\// &&
        $f !~ m/\.c$/ &&
        $file_s =~ m/\b$wd\b/) {
      print "$f\t\# $wd must be vcl_$wd\n";
      $printed = 1;
    }
  }

# 11. Multiple empty lines, empty line before } or after {
#   (mentioned only if something else is already printed, or is -f given)
  if ($printed && $file =~ m/\n\n\n\n/) {
    print "$f\t\# contains multiple (>=3) empty lines\n";
  }
  print "$f\t\# has lines ending in spaces\n"
    if ($printed && $has_end_spaces);
  print "$f\t\# has empty lines before closing brace\n"
    if ($printed && $file =~ m/\n\n[ \t]*\};*\s*\n/);
  print "$f\t\# has empty lines after opening brace\n"
    if ($printed && $file =~ m/\n[ \t]*\{\s*\n\n/);

# 12. no end-of-line at end-of-file
  $file =~ s/.*(.)//;
  unless ($file =~ m/\n/ || $file eq "") {
    print "$f\t\# has no final end-of-line\n";
  }
}
