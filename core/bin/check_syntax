#! /bin/sh
exec perl -w -x $0 ${1+"$@"}
#!perl
#line 5

# Purpose: list all files in the vxl source tree that have tab characters
# (and that shouldn't have them because vxl c++ source files shouldn't).

undef $/;
$full = "";

while (defined($ARGV[0]) && $ARGV[0] =~ m/^-/) {
  $_ = shift(@ARGV);
  if (m/^-f$/) {
    $full = 1;
  }
  else {
    printf STDERR "Unrecognised command line option $_ ignored\n";
  }
}

if (defined($ARGV[0])) {
  @FILES = @ARGV;
}
else {
  $IUEROOT = $ENV{IUEROOT};
  unless (defined($IUEROOT)) {
    print STDERR "IUEROOT is not defined, and no command line arguments were given\n";
    exit 0;
  }
  $FILES = `find $IUEROOT/config $IUEROOT/vcl $IUEROOT/v3p $IUEROOT/vxl $IUEROOT/mul $IUEROOT/oxl $IUEROOT/gel $IUEROOT/tbl $IUEROOT/conversions -type f \\\( -name \\\*.cxx -o -name \\\*.txx -o -name \\\*.cc -o -name \\\*.cpp -o -name \\\*.c -o -name \\\*.h \\\) -print|grep -v /gel/v.ol\\.new/`;
  @FILES = split(' ', $FILES);
}

foreach $f (@FILES)
{
  unless (open(FILE, $f)) {
    print STDERR "File $f does not exist\n";
    next;
  }
  $file=<FILE>;
  close FILE;
  next unless (defined($file));
  $printed = $full;

# 1. abnormal characters (tabs, ascii < 32, etc.)
  if ($file =~ m/\t/) {
    print "$f\t\# contains tabs\n";
    $printed = 1;
  }
  if ($file =~ m/\r/ && $f !~ m/\.ds[pw]$/) {
    print "$f\t\# contains carriage returns (ascii 13)\n";
    $printed = 1;
  }
  if ($file =~ m/[\000-\010\013\014\016-\037\177-\277\320\327\336\360\367\376]/) {
    print "$f\t\# contains non-standard ascii characters\n";
    $printed = 1;
  }

# 2. spaces (more than 1) at end of line
  $has_end_spaces = ($file =~ m/  +\n/);

# 3. Lines longer than 132 characters
  if ($file =~ m/[^\n]{133,}/ && $f !~ m/\.dsp$/) {
    print "$f\t\# has lines of more than 132 characters\n";
    $printed = 1;
  }

# 4. Consecutive comment blocks, separated by blank lines
  if ($file =~ m+\n\s*//:[^\n]*\n( *// [^\n]*\n)*\s*\n\s*// +) {
    print "$f\t\# contains comment blocks separated by a blank line; consider joining them\n";
    $printed = 1;
  }

# 5. //: inside a comment block, or \file not after //:
  if ($file =~ m+\n\s*//[ :][^\n]*\n *//:+) {
    print "$f\t\# contains //: inside a comment block\n";
    $printed = 1;
  }
  if ($file =~ m+\n\s*//[^:][^\n]*\n *// *\\file\b+ ||
      $file =~ m+\n\s*[^\s/][^\n]*\n *// *\\file\b+) {
    print "$f\t\# \\file is not preceeded by //:\n";
    $printed = 1;
  }

# 7. Comments: long /* ... */ and old-style // -- docs
  $file =~ s/ +\n/\n/g;
  $file =~ s/\/\*/\001/g; $file =~ s/\/\001/\/\/\*/g;
  $file =~ s/\*\//\002/g;
  $file =~ s/(\"[^\001\n\"]{0,15})\001([^\001\n\"]{0,15}\")/$1\/\*$2/g;
  $file =~ s/(\"[^\002\n\"]{0,15})\002([^\002\n\"]{0,15}\")/$1\*\/$2/g;
  if ($file =~ m/\/\/\s*[a-zA-Z_0_9]*\s*--\s/) {
    print "$f\t\# contains old style // -- docs\n";
    $printed = 1;
  }
  if ($f !~ m/\.c$/ &&
      $f !~ m/_mocced\.cxx$/ &&
      $f !~ m/\bv3p\/(tiff|netlib|jpeg|png|zlib|Qv)\// &&
      $f !~ m/\bfile_formats\/vil_viff(header|_support)/ &&
      $f !~ m/\bvgui\/internals\/trackball/ &&
      $f !~ m/\bgel\/vgel\/kl\/.*\.h$/ &&
      $f !~ m/\bvcl\/vcl_c/ &&
      $f !~ m/\bvcl\/emulation\// &&
      $file =~ m/\001[^\001\002]{111,}/)
  {
    print "$f\t\# contains long /*...*/ comments\n";
    $printed = 1;
  }
  if ($file =~ m/^\s*\/\/\s*vcl_c(out|err)\s*\<\<[^\n]*(\n\s*\/\/[^\n]*){5,}/) {
    print "$f\t\# consider commenting out code sections with #if 0 or #ifdef DEBUG\n";
    $printed = 1;
  }

# 8. RCS indications
  if ($file =~ m/(\$RCSfile)/) {
    print "$f\t\# contains RCS indication $1\n";
    $printed = 1;
  }

# 9. Now remove comments and string constants before checking further:
  $file_s = "\n" . $file;
  $file_s =~ s/\n\#if\s+0\s*\n.*?\n\#endif\s*\n/\n/g;
  # remove string constants, incl. multiline string constants with "correct syntax":
  $file_s =~ s/\\\n//g; $file_s =~ s/([^\\])\\\"/$1/g;
  $file_s =~ s/\".*?\"/\003/g;
  # replace :: by \005 and -> by \006 (useful later)
  $file_s =~ s/::/\005/g;
  $file_s =~ s/->/\006/g;
  # remove // comments
  $file_s =~ s/\/\/[^\n]*\n/\n/g;
  # remove /* ... */ comments
  $file_s =~ s/\001[^\001\002]*\002//g;
# if ($file_s =~ m/[\001\002]/) {
#   print "$f\t\# contains nested comments\n";
#   $printed = 1;
# }
# continuation lines:
  $file_s =~ s/\\\n//g;

# 10. Multi-line string constant
  if ($file_s =~ m/\"/) {
    print "$f\t\# contains multi-line string constant\n";
    $printed = 1;
  }
# 11. Inclusion guard
  if ($file_s =~ m/^\s*\#ifndef\s+(\S+)\s*\n#define\s+\1\s*\n/) {
    $guard = $1;
    if (defined($inclusion_guards{"$guard"})) {
      print "$f\t\# has the same inclusion guard as " . $inclusion_guards{"$guard"} . "\n";
      $printed = 1;
    }
    else {
      $inclusion_guards{"$guard"} = "$f";
    }
    undef $guard;
  }
  else {
    unless ($f !~ m/\.(txx|h)$/ ||
            $f =~ m/vcl\/emulation\/.*stlco(nf|mp)\.h$/ ||
            $f =~ m/vcl\/vcl_typeinfo\.h$/ ||
            $f =~ m/v3p\/(jpeg|tiff|zlib)\// ||
            $f =~ m/\/resource\.h$/i ||
            $f =~ m/vcl(\/win32)?\/vcl_c(assert|string)/ ||
            $file_s eq "\n")
    {
      print "$f\t\# has no (valid) inclusion guard\n";
      $printed = 1;
    }
  }

# 12. Constant pi written as 3.1415...
  if ($f !~ m/\b(v[cuib]l|v3p)\// && $f !~ m/\bvxl\/vnl\/vnl_math\./ && $f !~ m/\.c$/ &&
      $file_s =~ m/\b(3\.14159\d*)/) {
    print "$f\t\# should maybe use vnl_math::pi instead of $1\n";
    $printed = 1;
  }

# 13. Instantiation macro stuff
  if ($file_s =~ m/\#define\s+(\S*INSTANTIATE[^\s\(\)]*)[^\n]+;\s*\n/) {
    print "$f\t\# definition of $1 ends with ;\n";
    $printed = 1;
  }
  if ($file_s =~ m/\#define\s+(\S*INSTANTIATE[^\s\(\)]*)\s*\([^)]*\)\S/) {
    print "$f\t\# definition of $1 does not start with a space\n";
    $printed = 1;
  }
  if ($file_s =~ m/\#define\s+(\S*INSTANTIATE[^\s\(\)]*)[^\n]+(\<[^<>\n]*[A-Za-z_][A-Za-z_0-9]*\>)/) {
    print "$f\t\# definition of $1 has no space before > in $2\n";
    $printed = 1;
  }
# Presence of VCL_*_INSTANTIATE in *.cxx files outside Templates directories
  if ($f !~ m+/Templates/+ &&
      $f !~ m+vcl/tests/test_vcl_rel_ops\.cxx$+ &&
      $f !~ m+vxl/vsl/tests/test_polymorphic_io\.cxx$+ &&
      $f !~ m+oxl/vgui/examples/awf/glmovie\.cxx$+ &&
      $file_s =~ m+\n\s*(VCL_[_A-Z]*INSTANTIATE[_A-Z]*)+) {
    print "$f\t\# $1 may only be used in Templates subdirectories\n";
    $printed = 1;
  }
# Check correct file name of *.cxx files in Templates directories
  $file_s =~ s/VCL_DO_NOT_INSTANTIATE/VCL_do_not_INSTANTIATE/g;
  if ($f =~ m+/Templates/+ &&
      $f !~ m+vcl/Templates/(complex|string)-instances\.cxx$+ &&
      $f !~ m+vxl/vnl/algo/Templates/fsm_pack\.cxx$+ &&
      $f !~ m+vxl/vbl/examples/Templates/smartptr-instances\.cxx$+ &&
      $f !~ m+vxl/vnl/Templates/vnl_matrix_fixed_pairwise_ops\.cxx$+ &&
      $file_s =~ m/\b([_A-Z0-9]*)_INSTANTIATE\s*\((.*)\)/) {
    $class=$1; $class =~ tr/A-Z/a-z/; $class="$class<$2>";
    $class =~ s/\bvcl_swap\s*\</vcl_algorithm\</g;
    $class =~ s/\bvcl_sort\s*\<[^,]+\,/vcl_algorithm\</g;
    $class =~ s/\bvcl_find_if\s*\<\s*vcl_vector\s*\<([^\005]+)\005\s*iterator.+/vcl_algorithm\<$1/g;
    while ($file_s =~ m/\btypedef\s+([^;]*)\s(\S+)\s*\;/)
    { $A=$1; $B=$2; $B =~ s/([][{}()|*+\/\\])/\\$1/g; $class =~ s/\b$B\b/$A/g; $file_s =~ s/\btypedef\s[^;]*\;//; }
#   $class =~ s/\bconst\b//g;
    $class =~ s/\s//g;
    $class =~ s/\bconstchar/const_char/g; $class =~ s/(\w)const/$1_const/g;
    $class =~ s/\,vcl_less\<[^<>]+\<[^<>]+\>[^<>]*\>//g;
    $class =~ s/\,vcl_less\<[^<>]+\>//g;
    $class =~ s/(vbl_io_sparse_array)_base\</$1\</g;
    $class =~ s/\005/+-/g; $class =~ tr/<,*>/+.~-/; # \005 is ::
    $class_q = $class; $class_q =~ s/([.+~-])/\\$1/g;
    $class =~ s/unsigned/u/g; $class =~ s/signed/s/g; $class =~ s/longd/long_d/g;
    $class_r = $class; $class_r =~ s/([.+~-])/\\$1/g;
    $class_s = $class_q; $class_s =~ s/signed/signed_/g; $class_s =~ s/long/long_/g;
    if ($f !~ m/\/$class_q\.(cxx|cc|C)$/ &&
        $f !~ m/\/$class_r\.(cxx|cc|C)$/ &&
        $f !~ m/\/$class_s\.(cxx|cc|C)$/) {
      print "$f\t\# should be renamed to $class.cxx\n";
      $printed = 1;
    }
  }

# 14. Missing vcl_
  foreach $wd (split(' ',"abort exit")) {
    if ($f !~ m/\bv3p\/(netlib|jpeg|png|zlib)\// &&
        $f !~ m/\.c$/ &&
        "$f.$wd" !~ m/\bvcl\/tests\/test_vcl_exception\.cxx\.abort$/ &&
        $file_s =~ m/\b$wd\s*(\s*)\(/) {
      print "$f\t\# $wd$1() must be vcl_$wd()\n";
      $printed = 1;
    }
  }
  foreach $wd (split(' ',"complex real imag conj arg polar abs acos asin atan atan2 ceil cos exp fabs floor log min max pow sin sqrt")) {
    if ($f !~ m/\bvcl(\/[^\/]+)?\/vcl_(cmath|complex|cstdlib)\./ &&
        $f !~ m/\bv3p\/(netlib|tiff|png)\// && $f !~ m/\bv3p\/Qv\/vectors\.h$/ &&
        $f !~ m/\.c$/ &&
        $f !~ m/\bvnl\/vnl_complex_ops\.txx$/ &&
        "$f.$wd" !~ m/\bvul\/vul_timer\.(h|cxx)\.real$/ &&
        "$f.$wd" !~ m/\bvnl\/vnl_quaternion\.h\.real$/ &&
        "$f.$wd" !~ m/\bvnl\/(vnl_rational\.h|tests\/test_rational\.cxx)\.(abs|ceil|floor)$/ &&
        "$f.$wd" !~ m/\bvnl\/vnl_numeric_limits\.h\.(min|max)$/ &&
        "$f.$wd" !~ m/\bvil\/vil_rgb\.(h|txx)\.(min|max)$/ &&
        "$f.$wd" !~ m/\bvbl\/vbl_bounding_box\.(h|txx)\.(min|max)$/ &&
        "$f.$wd" !~ m/\bgel\/vgel\/kl\/base\.h\.(min|max)$/ &&
        "$f.$wd" !~ m/\bmul\/mbl\/mbl_stats_1d\.h\.(min|max)$/ &&
        "$f.$wd" !~ m/\boxl\/mvl\/HomgConic\.(h|cxx)\.polar$/ &&
        "$f.$wd" !~ m/\bvnl\/algo\/vnl_rn?poly_(solve|roots)\.h\.(real|imag)$/ &&
        $file_s =~ m/[^.\005\006]\b$wd\s*(\s*)\(/) { # \005 is :: and \006 is ->
      print "$f\t\# $wd$1() must be vcl_$wd()\n";
      $printed = 1;
    }
  }
  foreach $wd (split(' ',"cin cout cerr clog endl ends flush ios istream ostream fstream ifstream ofstream strstream ostrstream streambuf streamoff streamsize fpos streampos stringstream")) {
    if ($f !~ m/\bvcl\/.*\bvcl_(ios|iosfwd|iomanip|[siof]+stream|strstream|streambuf)\.h/ &&
        $f !~ m/\bvcl\/Templates\/stream-instances\.cxx$/ &&
        $f !~ m/\bv3p\/(netlib|jpeg|tiff|png|zlib)\// &&
        $file_s =~ m/[^ .]\s*\b$wd\b\s*[^ (]/) {
      print "$f\t\# $wd must be vcl_$wd\n";
      $printed = 1;
    }
  }
  foreach $wd (split(' ',"basefield floatfield adjustfield fmtflags seekdir")) {
    if ($f !~ m/\bvcl\/.*\bvcl_(ios|iosfwd|iomanip|[siof]+stream|strstream|streambuf)\.h/ &&
        $f !~ m/\bv3p\/(netlib|jpeg|tiff|png|zlib)\// &&
        $file_s =~ m/[^ .]\s*\b$wd\b\s*[^ (]/) {
      print "$f\t\# $wd must be vcl_ios_$wd\n";
      $printed = 1;
    }
  }
  foreach $wd (split(' ',"beg cur end")) {
    if ($f !~ m/\bvcl\/.*\bvcl_(ios|iosfwd|iomanip|[siof]+stream|strstream|streambuf)\.h/ &&
        $f !~ m/\bv3p\/(netlib|jpeg|tiff|png|zlib)\// &&
        ($f !~ m/\bvcl\/emulation\/vcl_string\.h$/ || $wd !~ m/end/ ) &&
        $file_s =~ m/,\s*$wd\s*\)/) {
      print "$f\t\# $wd must be vcl_ios_$wd\n";
      $printed = 1;
    }
  }
  foreach $wd (split(' ',"boolalpha noboolalpha showbase noshowbase showpoint noshowpoint showpos noshowpos skipws noskipws uppercase nouppercase")) {
    if ($f !~ m/\bvcl\/.*\bvcl_(ios|iosfwd|iomanip|[siof]+stream|strstream|streambuf)\.h/ &&
        $f !~ m/\bv3p\/(netlib|jpeg|tiff|png|zlib)\// &&
        $file_s =~ m/[^ .]\s*\b$wd\b\s*[^ (]/) {
      print "$f\t\# $wd must be vcl_ios_$wd\n";
      $printed = 1;
    }
    if ($f !~ m/\bvcl\/.*\bvcl_(ios|iosfwd|iomanip|[siof]+stream|strstream|streambuf)\.h/ &&
        $file_s =~ m/\b$wd\s*\(/) {
      print "$f\t\# $wd() must be vcl_$wd()\n";
      $printed = 1;
    }
  }
  foreach $wd (split(' ',"internal left right")) {
    if ($f !~ m/\bvcl\/.*\bvcl_(ios|iosfwd|iomanip|[siof]+stream|strstream|streambuf)\.h/ &&
        $f !~ m/\bv3p\/(netlib|jpeg|tiff|png|zlib)\// &&
        ($f !~ m/\bvcl\/emulation\/vcl_(algorithm|tree).h$/ || $wd !~ m/(left|right)/ ) &&
        ($f !~ m/\bvnl\/(vnl_matrix\.txx|algo\/vnl_complex_eigensystem\.cxx)$/ || $wd !~ m/(left|right)/ ) &&
        ($f !~ m/\b(oxl\/oxp\/vsl_conic_points\.cxx|gel\/gevd\/gevd_float_operators\.cxx)$/ || $wd !~ m/(left|right)/ ) &&
        $file_s =~ m/[^ .>]\s*\b$wd\s*[|),]/) {
      print "$f\t\# $wd must be vcl_ios_$wd\n";
      $printed = 1;
    }
    if ($f !~ m/\bvcl\/.*\bvcl_(ios|iosfwd|iomanip|[siof]+stream|strstream|streambuf)\.h/ &&
        $file_s =~ m/\bvcl_ios_$wd\s*[^ ,]/ &&
        $file_s !~ m/(vcl_resetiosflags|\.\s*unsetf)\s*\((vcl_ios_(internal|left|right)\s*\|\s*)*vcl_ios_$wd\s*(\|\s*vcl_ios_(internal|left|right)\s*)*\)/) {
      print "$f\t\# vcl_ios_$wd must be used together with vcl_ios_adjustfield\n";
      $printed = 1;
    }
    if ($f !~ m/\bvcl\/.*\bvcl_(ios|iosfwd|iomanip|[siof]+stream|strstream|streambuf)\.h/ &&
        ($f !~ m/\bvcl\/emulation\/vcl_tree\.h$/ || $wd !~ m/^(left|right)$/) &&
        ($f !~ m/\boxl\/oxp\/vsl_conic_points\.cxx$/ || $wd !~ m/(left|right)/ ) &&
        $file_s =~ m/\b$wd\s*\(/) {
      print "$f\t\# $wd() must be vcl_$wd()\n";
      $printed = 1;
    }
  }
  foreach $wd (split(' ',"dec hex oct")) {
    if ($f !~ m/\bvcl\/.*\bvcl_(ios|iosfwd|iomanip|[siof]+stream|strstream|streambuf)\.h/ &&
        $file_s =~ m/\b$wd\s*[|),]/) {
      print "$f\t\# $wd must be vcl_ios_$wd\n";
      $printed = 1;
    }
    if ($f !~ m/\bvcl\/.*\bvcl_(ios|iosfwd|iomanip|[siof]+stream|strstream|streambuf)\.h/ &&
        $file_s =~ m/\bvcl_ios_$wd\s*[^ ,]/ &&
        $file_s !~ m/(vcl_resetiosflags|\.\s*unsetf)\s*\((vcl_ios_(dec|hex|oct)\s*\|\s*)*vcl_ios_$wd\s*(\|\s*vcl_ios_(dec|hex|oct)\s*)*\)/) {
      print "$f\t\# vcl_ios_$wd must be used together with vcl_ios_basefield\n";
      $printed = 1;
    }
    if ($f !~ m/\bvcl\/.*\bvcl_(ios|iosfwd|iomanip|[siof]+stream|strstream|streambuf)\.h/ &&
        $file_s =~ m/\b$wd\s*\(/) {
      print "$f\t\# $wd() must be vcl_$wd()\n";
      $printed = 1;
    }
  }
  foreach $wd (split(' ',"scientific fixed")) {
    if ($f !~ m/\bvcl\/.*\bvcl_(ios|iosfwd|iomanip|[siof]+stream|strstream|streambuf)\.h/ &&
        ($f !~ m/\bvpdfl\/vpdfl_pc_gaussian_builder\./ || $wd !~ m/^fixed$/) &&
        $file_s =~ m/\b$wd\s*[|),]/) {
      print "$f\t\# $wd must be vcl_ios_$wd\n";
      $printed = 1;
    }
    if ($f !~ m/\bvcl\/.*\bvcl_(ios|iosfwd|iomanip|[siof]+stream|strstream|streambuf)\.h/ &&
        $file_s =~ m/\bvcl_ios_$wd\s*[^ ,]/ &&
        ($f !~ m/\bvpdfl\/vpdfl_pc_gaussian_builder\./ || $wd !~ m/^fixed$/) &&
        $file_s !~ m/(vcl_resetiosflags|\.\s*unsetf)\s*\((vcl_ios_(scientific|fixed)\s*\|\s*)*vcl_ios_$wd\s*(\|\s*vcl_ios_(scientific|fixed)\s*)*\)/) {
      print "$f\t\# vcl_ios_$wd must be used together with vcl_ios_floatfield\n";
      $printed = 1;
    }
    if ($f !~ m/\bvcl\/.*\bvcl_(ios|iosfwd|iomanip|[siof]+stream|strstream|streambuf)\.h/ &&
        $file_s =~ m/\b$wd\s*\(/) {
      print "$f\t\# $wd() must be vcl_$wd()\n";
      $printed = 1;
    }
  }
  foreach $wd (split(' ',"size_t ptrdiff_t clock_t time_t")) {
    if ($f !~ m/\bvcl\/.*\bvcl_c(stddef|stdio|time)\./ &&
        $f !~ m/\bv3p\/(jpeg|tiff|png)\// &&
        $f !~ m/\.c$/ &&
        $file_s =~ m/\b$wd\b/) {
      print "$f\t\# $wd must be vcl_$wd\n";
      $printed = 1;
    }
  }
  foreach $wd (split(' ',"iterator_traits back_insert_iterator front_insert_iterator insert_iterator input_iterator_tag output_iterator_tag forward_iterator_tag bidirectional_iterator_tag random_access_iterator_tag")) {
    if ($f !~ m/\bvcl\/.*\bvcl_iterator\.(h|txx)$/ &&
        $f !~ m/\bv3p\/(jpeg|tiff|png)\// &&
        $file_s =~ m/\b$wd\b/) {
      print "$f\t\# $wd must be vcl_$wd\n";
      $printed = 1;
    }
  }

# 15. Multiple empty lines, empty line before } or after {
#   (mentioned only if something else is already printed, or is -f given)
  if ($printed && $file =~ m/\n\n\n\n/) {
    print "$f\t\# contains multiple (>2) empty lines\n";
  }
  print "$f\t\# has lines ending in spaces\n"
    if ($printed && $has_end_spaces);
  print "$f\t\# has empty lines before closing brace\n"
    if ($printed && $file =~ m/\n\n[ \t]*\};*\s*\n/);
  print "$f\t\# has empty lines after opening brace\n"
    if ($printed && $file =~ m/\n[ \t]*\{\s*\n\n/);

# 16. no end-of-line at end-of-file
  $file =~ s/.*(.)//;
  unless ($file =~ m/\n/ || $file eq "") {
    print "$f\t\# has no final end-of-line\n";
  }
}
