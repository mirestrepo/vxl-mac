Inner loops of different methods:
Method1: for (unsigned i=0;i<image.ni();++i) image(i,j,p) = vxl_byte(i+j+3*p);
Method2: for (unsigned i=0;i<ni;++i) image(i,j,p) = vxl_byte(i+j+3*p);
Method3: for (unsigned i=0;i<image.ni();++i,pixel+=image.istep()) *pixel = vxl_byte(i+j+3*p);
Method4: for (unsigned i=0;i<ni;++i,pixel+=istep) *pixel = vxl_byte(i+j+3*p);


Times to fill a 256 x 256 image of 3 planes (in microsecs) [Range= 0.5(max-min)]

550MHz Linux Box, using gcc-2.95.2
----------------------------------
No optimisation:
Method 1) Mean: 21210us  +/-100us
Method 2) Mean: 18100us  +/-0us
Method 3) Mean: 11650us  +/-50us
Method 4) Mean: 4750us  +/-50us
Method 5) Mean: 4810us  +/-50us

Using -O2:
Method 1) Mean: 5920us  +/-100us
Method 2) Mean: 6430us  +/-100us
Method 3) Mean: 1850us  +/-50us
Method 4) Mean: 2210us  +/-50us
Method 5) Mean: 2090us  +/-50us

Using -O3:
Method 1) Mean: 5950us  +/-200us
Method 2) Mean: 6550us  +/-300us
Method 3) Mean: 1900us  +/-350us
Method 4) Mean: 2220us  +/-50us
Method 5) Mean: 2040us  +/-50us

Conclusion: Methods 3&4 (using pointer incrementing) about 1000x faster than im(i,j,p)

850Mhz P3 Windows 2000, using MSVC 6.0 SP5
------------------------------------------
No Optimisation (Debug)
Times to fill a 256 x 256 image of 3 planes

Optimisation with specified inlining (with debug info added) (RelwithDebInfo)
Times to fill a 256 x 256 image of 3 planes

Optimisation with optimiser controlled inlining (with debug info added)
Times to fill a 256 x 256 image of 3 planes

