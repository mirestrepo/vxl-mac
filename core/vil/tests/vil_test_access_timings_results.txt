Inner loops of different methods:
Method1: for (unsigned i=0;i<image.ni();++i) image(i,j,p) = vxl_byte(i+j+3*p);
Method2: for (unsigned i=0;i<ni;++i) image(i,j,p) = vxl_byte(i+j+3*p);
Method3: for (unsigned i=0;i<image.ni();++i,pixel+=image.istep()) *pixel = vxl_byte(i+j+3*p);
Method4: for (unsigned i=0;i<ni;++i,pixel+=istep) *pixel = vxl_byte(i+j+3*p);


Times to fill a 256 x 256 image of 3 planes (in microsecs) [Range= 0.5(max-min)]

550MHz Linux Box, using gcc-2.95.2
----------------------------------
No optimisation:
Method 1) Mean: 21188us  +/-20us
Method 2) Mean: 18108us  +/-400us
Method 3) Mean: 24us  +/-10us
Method 4) Mean: 10us  +/-10us
Method 5) Mean: 12us  +/-10us

Using -O2:
Method 1) Mean: 5966us +/-120us
Method 2) Mean: 6416us +/-10us
Method 3) Mean:    4us +/-10us
Method 4) Mean:    4us +/-10us
Method 5) Mean:    4us +/-10us

Using -O3:
Method 1) Mean: 5950us  +/-100us
Method 2) Mean: 6438us  +/-180us
Method 3) Mean:    8us  +/-10us
Method 4) Mean:    4us  +/-10us
Method 5) Mean:    2us  +/-10us

Conclusion: Methods 3&4 (using pointer incrementing) about 1000x faster than im(i,j,p)

850Mhz P3 Windows 2000, using MSVC 6.0 SP5
------------------------------------------
No Optimisation (Debug)
Times to fill a 256 x 256 image of 3 planes
Method 1) Mean: 14.3103ms   sd:0.0559454ms
Method 2) Mean: 11.9907ms   sd:0.0138884ms
Method 3) Mean: 0.0233333ms   sd:0.0152753ms
Method 4) Mean: 0.00666667ms   sd:0.0133333ms

Optimisation with specified inlining (with debug info added) (RelwithDebInfo)
Times to fill a 256 x 256 image of 3 planes
Method 1) Mean: 3.53167ms   sd:0.0195078ms
Method 2) Mean: 3.21133ms   sd:0.0127541ms
Method 3) Mean: 0.00333333ms   sd:0.01ms
Method 4) Mean: 0.00333333ms   sd:0.01ms

Optimisation with optimiser controlled inlining (with debug info added)
Times to fill a 256 x 256 image of 3 planes
Method 1) Mean: 3.54867ms   sd:0.030485ms
Method 2) Mean: 3.221ms   sd:0.0226593ms
Method 3) Mean: 0.00666667ms   sd:0.0133333ms
Method 4) Mean: 0.00333333ms   sd:0.01ms

