Inner loops of different methods:
Method1: for (unsigned i=0;i<image.ni();++i) image(i,j,p) = vxl_byte(i+j+3*p);
Method2: for (unsigned i=0;i<ni;++i) image(i,j,p) = vxl_byte(i+j+3*p);
Method3: for (unsigned i=0;i<image.ni();++i,pixel+=image.istep()) *pixel = vxl_byte(i+j+3*p);
Method4: for (unsigned i=0;i<ni;++i,pixel+=istep) *pixel = vxl_byte(i+j+3*p);
Method5: for (unsigned i=ni;i;--i,pixel-=istep) *pixel = vxl_byte(i-1+j+3*p);
Method6: for (unsigned i=0;i<ni;++i) row[i] = vxl_byte(i+j+3*p);
  // Method 6 simulates partial lookup method of original vil
Method7: for (unsigned i=0;i<ni;++i) im_data[p][j][i] = vxl_byte(i+j+3*p);
  // Method 7 simulates complete lookup method of original vil
Method8: for (unsigned i=0;i<ni;++i) row[i*istep] = vxl_byte(i+j+3*p);

Times to fill a 256 x 256 image of 3 planes (in microsecs) [Range= 0.5(max-min)]


----------------------------------------------------------------------------
GCC 2.95.x
----------------------------------------------------------------------------


550MHz P3 Linux Box, using gcc-2.95.2
----------------------------------
No optimisation:
Method 1) Mean: 21210us  +/-100us
Method 2) Mean: 18100us  +/-0us
Method 3) Mean: 11650us  +/-50us
Method 4) Mean: 4750us  +/-50us
Method 5) Mean: 4810us  +/-50us
Method 6) Mean: 4390us  +/-100us

Using -O2:
Images of BYTE
Method 1) Mean: 6180us  +/-2250us
Method 2) Mean: 6340us  +/-650us
Method 3) Mean: 1860us  +/-100us
Method 4) Mean: 2220us  +/-100us
Method 5) Mean: 2260us  +/-50us
Method 6) Mean: 1190us  +/-50us
Method 7) Mean: 1880us  +/-100us
Method 8) Mean: 2230us  +/-100us
Images of FLOAT
Method 1) Mean: 14220us  +/-500us
Method 2) Mean: 15540us  +/-900us
Method 3) Mean: 13750us  +/-600us
Method 4) Mean: 11120us  +/-350us
Method 5) Mean: 11340us  +/-200us
Method 6) Mean: 11520us  +/-100us
Method 7) Mean: 11500us  +/-100us
Method 8) Mean: 10940us  +/-50us

Using -O3:
Method 1) Mean: 5950us  +/-200us
Method 2) Mean: 6550us  +/-300us
Method 3) Mean: 1900us  +/-350us
Method 4) Mean: 2220us  +/-50us
Method 5) Mean: 2040us  +/-50us
Method 6) Mean: 1200us  +/-100us

Conclusion: Methods 3&4 (using pointer incrementing) about 3x faster than im(i,j,p) for byte
Lookup appears to be significantly faster than pointer arithmetic!
Differences far less significant for floats (which are much slower: about 5x slower!)

450MHz P3 Linux Box, using egcs-2.91.66
---------------------------------------
Using -O2:
Images of BYTE
Method 1) Mean: 7970us  +/-100us
Method 2) Mean: 8360us  +/-50us
Method 3) Mean: 5210us  +/-100us
Method 4) Mean: 5210us  +/-50us
Method 5) Mean: 4900us  +/-100us
Method 6) Mean: 1810us  +/-50us
Method 7) Mean: 5170us  +/-50us
Method 8) Mean: 5120us  +/-50us
Images of FLOAT
Method 1) Mean: 14400us  +/-100us
Method 2) Mean: 14270us  +/-50us
Method 3) Mean: 11800us  +/-200us
Method 4) Mean: 11390us  +/-450us
Method 5) Mean: 10100us  +/-300us
Method 6) Mean: 11220us  +/-550us
Method 7) Mean: 11070us  +/-100us
Method 8) Mean: 11340us  +/-300us


1.1 GHz AMD FreeBSD 4.5, using gcc-2.95.3
-----------------------------------------
No optimization:
Method 1) Mean: 10938us  +/-156us
Method 2) Mean: 9984us  +/-39us
Method 3) Mean: 5555us  +/-39us
Method 4) Mean: 2008us  +/-39us
Method 5) Mean: 2023us  +/-39us

No optimization with -DNDEBUG:
Method 1) Mean: 8766us  +/-78us
Method 2) Mean: 7133us  +/-117us
Method 3) Mean: 5188us  +/-78us
Method 4) Mean: 2148us  +/-39us
Method 5) Mean: 2109us  +/-78us

Using -g -O2:
Method 1) Mean: 2883us  +/-78us
Method 2) Mean: 3398us  +/-39us
Method 3) Mean: 914us  +/-39us
Method 4) Mean: 750us  +/-39us
Method 5) Mean: 742us  +/-39us

Using -g -O2 -DNDEBUG
Method 1) Mean: 2617us  +/-39us
Method 2) Mean: 3219us  +/-39us
Method 3) Mean: 914us  +/-39us
Method 4) Mean: 750us  +/-39us
Method 5) Mean: 742us  +/-39us

Using -g -O3 -DNDEBUG:
Method 1) Mean: 2523us  +/-78us
Method 2) Mean: 3219us  +/-39us
Method 3) Mean: 820us  +/-39us
Method 4) Mean: 750us  +/-39us
Method 5) Mean: 734us  +/-39us

Using -O3 -NDEBUG:
Method 1) Mean: 2531us  +/-39us
Method 2) Mean: 2688us  +/-39us
Method 3) Mean: 750us  +/-39us
Method 4) Mean: 836us  +/-39us
Method 5) Mean: 742us  +/-39us

Using -DNDEBUG -O3 -funroll-loops:
Method 1) Mean: 2609us  +/-78us
Method 2) Mean: 2625us  +/-39us
Method 3) Mean: 766us  +/-78us
Method 4) Mean: 508us  +/-39us
Method 5) Mean: 477us  +/-39us


----------------------------------------------------------------------------
GCC 3.0.x
----------------------------------------------------------------------------

1.1 GHz AMD FreeBSD 4.5, using gcc 3.0.4
----------------------------------------
No optimization:
Method 1) Mean: 10352us  +/-117us
Method 2) Mean: 8391us  +/-78us
Method 3) Mean: 6305us  +/-78us
Method 4) Mean: 1844us  +/-78us
Method 5) Mean: 1797us  +/-78us

No optimization with -DNDEBUG:
Method 1) Mean: 7188us  +/-78us
Method 2) Mean: 5367us  +/-78us
Method 3) Mean: 5586us  +/-39us
Method 4) Mean: 1844us  +/-39us
Method 5) Mean: 1859us  +/-78us

Using -O2:
Method 1) Mean: 3320us  +/-78us
Method 2) Mean: 3039us  +/-39us
Method 3) Mean: 1328us  +/-0us
Method 4) Mean: 734us  +/-39us
Method 5) Mean: 898us  +/-39us

Using -O2 -DNDEBUG:
Method 1) Mean: 2516us  +/-39us
Method 2) Mean: 2695us  +/-78us
Method 3) Mean: 1266us  +/-39us
Method 4) Mean: 742us  +/-78us
Method 5) Mean: 898us  +/-39us

Using -O3 -DNDEBUG
Method 1) Mean: 2516us  +/-39us
Method 2) Mean: 2695us  +/-39us
Method 3) Mean: 1266us  +/-39us
Method 4) Mean: 734us  +/-39us
Method 5) Mean: 906us  +/-39us

Using -O3 -DNDEBUG -funroll-loops
Method 1) Mean: 2711us  +/-78us
Method 2) Mean: 2641us  +/-78us
Method 3) Mean: 1289us  +/-117us
Method 4) Mean: 477us  +/-78us
Method 5) Mean: 898us  +/-39us



----------------------------------------------------------------------------
MSVC 6.0 SP5
----------------------------------------------------------------------------


850Mhz P3 Windows 2000, using MSVC 6.0 SP5
------------------------------------------
No Optimisation (Debug)
Images of BYTE
Method 1) Mean: 13920us  +/-100us
Method 2) Mean: 11746us  +/-55us
Method 3) Mean: 7341us  +/-55us
Method 4) Mean: 2844us  +/-55us
Method 5) Mean: 2834us  +/-55us
Method 6) Mean: 3245us  +/-50us
Method 7) Mean: 4006us  +/-5us
Method 8) Mean: 3775us  +/-55us
Images of FLOAT
Method 1) Mean: 19348us  +/-255us
Method 2) Mean: 17134us  +/-250us
Method 3) Mean: 11777us  +/-55us
Method 4) Mean: 7271us  +/-55us
Method 5) Mean: 7030us  +/-50us
Method 6) Mean: 6860us  +/-150us
Method 7) Mean: 7070us  +/-150us
Method 8) Mean: 7291us  +/-55us

Optimisation with specified inlining (with debug info added) (RelwithDebInfo)
Images of BYTE
Method 1) Mean: 3545us  +/-55us
Method 2) Mean: 3214us  +/-55us
Method 3) Mean: 1402us  +/-95us
Method 4) Mean: 1182us  +/-55us
Method 5) Mean: 751us  +/-55us
Method 6) Mean: 721us  +/-50us
Method 7) Mean: 721us  +/-50us
Method 8) Mean: 741us  +/-50us
Images of FLOAT
Method 1) Mean: 6259us  +/-55us
Method 2) Mean: 6259us  +/-50us
Method 3) Mean: 5758us  +/-55us
Method 4) Mean: 5849us  +/-105us
Method 5) Mean: 5838us  +/-105us
Method 6) Mean: 5749us  +/-50us
Method 7) Mean: 5768us  +/-100us
Method 8) Mean: 5828us  +/-55us

Optimisation with optimiser controlled inlining (with debug info added)
Method 1) Mean: 3545us  +/-55us
Method 2) Mean: 3214us  +/-50us
Method 3) Mean: 1402us  +/-5us
Method 4) Mean: 1192us  +/-50us
Method 5) Mean: 741us  +/-50us

Conclusion: Methods 5  (using pointer incrementing) about 5x faster than im(i,j,p) for byte
No significant difference lookup vs pointers
Differences far less significant for floats (which are much slower: about 8x slower!)

