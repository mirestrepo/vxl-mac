Notes for vil2



Problems with existing vil

It doesn't support planes very well.

Pointer indexing rather than arithmetic indexing
  Pointers are slower than arithmetic on most modern platforms
  It is hard to build a 2d image from a slice of 3d data

The vil_image smart pointer stuff is confusing.
  Is it a view, is it a smart ptr, is it a smart smart ptr.

There are some fundamental divisions
  1. data directly accessible v. data downloadable
  2. data type known at compile time v. data type known at run time.
  3. data ordering known a priori, v. data ordering known after image loading.
  Do these not indicate that trying to have a single image type (or hierarchy) is incorrect

What does the single vil_image hierarchy actually give you?


Good points about existing vil:

The functional notation vil_image im = vil_load("filename") is very nice

Support for processing very large images on disk.



Philosophy:

We want a single "normal" and "easy" image class that we can point new users at.
This should also be the default class for doing actual pixel manipulation.

We want to keep the type proliferation down. So we enforce the following idea
vil2_image_data is used when you don't know an image's pixel type,
and you can't immediately access the pixels. vil2_image_view is used when you know the type,
you know the structure and you can immediately access the pixels. By keeping this
division clean we can avoid type proliferation. There are limited exceptional cases. One is
when you absolutely must have a function that works on a view without knowing its pixel type - e.g.
vil2_image_data::get_view(). This means that all functions that actually work with pixels should
take a concrete vil_image_view<T>.

If you really want to mess around with an image without knowing
its type, then you should use an vil2_image_data_sptr object. Anyone who wants to write super-duper
size-no-problem image processing code, should write functions that take vil2_image_data_sptr.
However they will do the actual pixel processing with a vil2_image_view.

To get the functional style, most operations on a vil2_image_data, should be
on a vil2_image_data_sptr. Again consistency is good. vil2_image_data_sptr is very like
the old vil_image. However, here the smart pointer stuff is explict, and simple.


Questions with suggested answers:

Should vil_image_view::resize be virtual and in the base class? (It is in mil_image_2d)
Yes: it might be useful.

Should memory_chunk be templated?
No: You could have a memory_chunk containing rgb, and choose to view it as
a vil2_image_view<rgb<>> with nplanes=1, or vil2_image_view<char> with nplanes =3; It
is hard to get the type of the smart pointers correct without linking the types of the
vil2_memory_chunk and vil2_image_view. We can put a image type in a member variable for
when it is necessary.

Best order for x, y, plane in function calls.
x, y, plane: is common, and consistent (increasing step size in common image format)


Should functions dealing vil2_image_view really deal with vil2_image_view_sptr.
No: We want a single "normal" and "easy" image class. There are many functions on images
(e.g. single point sampling) which you want to happen very fast, smart pointer overhead is
undesirable in these cases. This establishes "normal" image class should be vil2_image_view.

Should vil_image_view be derived from vil_image_data?
No: It involves merging two different sets of functionality.

Should there be a general set_properties()?
No: Its existance implies the ability to set arbitrary properties. You can always have a
specialist set_obscure_tiff_property as a member function of vil2_tiff_file_image.


Questions:


Should n_planes, height, width return signed or unsigned int?
Signed has the advantage that it is much easier to pick up 0xffffffff errors.
Unsigned has the advantage that it makes the fixed 0,0 origin clear, and it reduces the number of
assertion checks needed (by exposing you to the 0xffffffff errors:)

Where should we put and what should we call functions on image_views, and functions on image_data
objects?

Best names for image_view, image_data, base_image?

Best name for height, width, rows, cols, nx, ny?
We would like just one set.


Should resize allow definition of assumed format? (eg RGBRGB or RRR BBB GGG etc)
Should deep_copy allow similar definition and thus possible re-ordering?
Should we have void set_to_window(im,...) functions, or just the image_view window(..) function.
Which of the following should really be member functions:
  print_all, window, deep_copy, set_to_window
The following are currently external functions:
  vil2_transpose, vil2_reflect_x, vil2_reflect_y, vil2_print_all

Pointers to data are often passed in as const, but may have the const removed.
This is because it is rather complicated to keep track of whether the data is going to be
changed or not.  Just try to be sensible, OK?

The vil2_image_view<T> has an operator= from its own base class. Is this sensible?
It allows for the simple conversion from the abstract base class which many functions will return
to a concrete class with a useful interface. It should also allow in time for the smart conversion
between various view formats.

There is now now way to get a bit-compressed pbm into memory efficiently. Is this a problem?
We could solve it by providing a vil2_image_view_of_compressed_bits, or somesuch.

deep_copy: Should it reformat, or should we have a separate function to do it?


Notes:

#includes to vxl/vil are simply to use old vil stuff that doesn't need to be converted. e.g. vil_stream


ToDo: - in order of priority.

Go through existing examples and VXL book and see if there are any idioms we have missed. - Done TFC

Add vil_crop style filter example for vil2_image_data. - Done IMS

Decide where to put world to image transforms and write it - vilt

Write vil2_save

Write vil2_memory_image

Write some example standard image processing code.

Add a set_view function to fill someone's existing view with data (which will probably be useful for implementing vil_clamp style filters)

Convert rest of file_images

Convert rest of vil2_image_data filters

Add a vil3D library.


Images with Transformations
---------------------------
We (Manchester) need images with associated "world to image" transformations.
In mil_image_2d_of<T> this is provided using a mil_transform_2d object which applies linear
transformations up to affine + projective.


We also need an image hierarchy with a base for both 2D and 3D images. There are very few 
functions which do not internally expect either the 2D or the 3D version, but it allows for
polymorphism between 2D models and 3D models. We have lots of code that polymorphically samples features from images into vectors and therefore deals with the concept of an image without needing to know its dimensionality, or pixel type.

To keep vil2 clean, whatever is created should be in a separate library (call it vilt).

Possible hierarchy:
        vilt_image
             |
        vilt_image_2d
                      vilt_transform_2d  world2im();
                      virtual vil2_image_view_base& view_base();
             |
       vilt_image_2d_of<T>
                      vil2_image_view<T> image();

This would then work pretty much as the current mil_image hierarchy

Advantages: Simple, known to work in mil

However, the transform is of fixed type
  - one can't replace it with, for instance, a non-linear warp


Alternative hierarchy:
        vilt_image
             |
        vilt_image_2d<TransformType>
                      TransformType  world2im();
                      virtual vil2_image_view_base& view_base();
             |
       vilt_image_2d_of<TransformType,T>
                      vil2_image_view<T> image();

TransformType must implement:
  vgl_point<double> operator()(x,y);
  vgl_point<double> operator()(vgl_point<double>);
  bool is_linear();   // Many things can be done much quicker if transform known to be affine
  bool is_identity(); // Many things can be skipped if tr(x) == x.

Advantages: Can use general transformations
Disadvantages:
  - More complex
  - In practise there probably aren't many times when you'll want to use non-linear warps
  - Quite a few of the current mil functions assume much more of the transform
    (eg can compose it with something which shrinks it by a known factor - for an image pyramid)
  - Beyond Affine+Projective the range of possible transforms is huge. At some point even, the
    warp size exceeds that of the image. We want a lightweight transform object, and so we
    pick one class.
    
that supports up to affine + projective.





