// The following text is included in the main documentation page by doxygen
/*! \mainpage vil2 : Proposed new core image library
* A set of classes to represent and manipulate images
*
* Broadly there are two sorts of image one is interested in - images in memory
* (all parts of which can be accessed directly) and external images (eg in files)
* which can only be accessed indirectly.  In most cases images in files are loaded
* into memory in one go, where they can then be manipulated.  However, for some
* very large images this is not possible or desirable.  In this case it is useful
* to be able to load in a sub-section of the image, manipulate it,and possible
* write it out again.  vil2 supports both memory images and external images.
*
* The core class is vil2_image_view<T> which gives a view of an image in memory.
* The only way to get at the pixel data in an image is through a vil2_image_view<T>.
*
* Large images (in files) can be accessed through the vil2_image_data class, but
* one can only get at the data by asking for a view of it, which loads the
* requested section into memory and creates a suitable vil2_image_view<T>.
*
* The vil2_image_view<T> represents a view of a multi-plane image of given type.
* A pointer is stored to the top-left pixel in the first plane of the image (top_left_ptr())
* and integers indicating how to get to neighbours in
* the x (xstep()) y (ystep()) and plane (planestep()) directions.
*
* The advantages of this approach are
* - It is actually faster than pointer indirection on most architectures
* - It allows one to access non-contiguous data as if it is a single plane
* - One can use it to wrap up other image classes transparently.
* - It is simple to extend to 3D images, and avoids huge arrays of pointers
*
*
* Note that the same colour image can either be viewed as a one plane image
* with RGB pixels (using vil2_image_view<vil_rgb<vil_byte> >) or as a 3 plane
* byte image (using vil2_image_view<vil_byte> with nplanes() == 3).
* \verbatim
vil2_image_view<vil_rgb<vil_byte> > rgb_image;
vil2_load(rgb_image,"my_image.jpg");

// Create a 3 plane view of rgb
vil2_image_view<vil_byte > three_plane_image =  vil2_view_as_planes(rgb_image);

 // Now create rgb view of 3 plane image (note: will abort if not possible)
vil2_image_view<vil_rgb<vil_byte> > rgb_image2 = vil2_view_as_rgb(three_plane_image);
\endverbatim
*
* \subsection copying Copying
* Since the vil2_image_view<T> is a `view' of the actual image data, copying one
* only copies the `view', not the image data itself - you get two views looking at
* the same chunk of memory.  Some cunning smart pointer stuff is used to ensure
* that the actual data remains as long as a valid view is looking at
* it.  (Note that this may not always be the case, since the view can be of
* a chunk of memory that the view does not have direct control of, such as a video
* buffer).  If you wish to copy the image data itself, then use the deep_copy()
* function.  This copies the raw data into a newly created space, and returns
* a new view of it.  Alternatively, use the function vil2_copy(dest_im,src_im);
*
* Example of loading, copying then processing:
* \verbatim
vil2_image_view<vil2_byte> image;
vil2_load(image,"test_image.jpg");
vil2_image_view<vil2_byte> image2 = image.deep_copy();
vil2_invert_image(image2);
vil2_save(image2,"output_image.jpg");
\endverbatim
*
* Example of creating an image in memory
* \verbatim
int nx=256;
int ny=256;
int nplanes=3;
vil2_image_view<vil2_byte> image(nx,ny,nplanes);
vil2_byte* plane_data = image.top_left_ptr();
for (int i=0;i<nplanes;++i)
  for (int y=0;y<ny;++y)
    for (int x=0;x<nx;++x)
      image(x,y,i) = vil2_byte(x+y+i);
\endverbatim
*
* Example of creating an image in memory, using fast pointer arithmetic
* \verbatim
  int nx=256;
  int ny=256;
  int nplanes=3;
  vil2_image_view<vil_byte> image(nx,ny,nplanes);
  vil_byte* plane = image.top_left_ptr();
  for (unsigned int p=0;p<nplanes;++p,plane += image.planestep())
  {
    vil_byte* row = plane;
    for (int y=0;y<ny;++y,row += image.ystep())
    {
      vil_byte* pixel = row;
      for (int x=0;x<nx;++x,pixel+=image.xstep())
        *pixel = vil_byte(x+10*y+100*p);
    }
  }
\endverbatim
*
* \subsection resize Resizing
* When one resizes a vil2_image_view<T>  the view disconnects from the data (which may then
* be deleted if no other views are connected), allocates a new chunk of memory for the new
* image and sets the view to look at it.
*
* Note that if the resize does not change the image size, then nothing is done and the view
* remains unchanged.
*
* \subsection view_manipulation Manipulating Views
* There are a variety of ways one can view the same data, allowing one to appear to
* change the data simply by changing ones view of it.
*
* For instance one can obtain a transposed view of an image simply by swapping nx-ny and
* xstep-ystep.  This is particularly useful when implementing decomposable filters, as
* one need only write it for one direction, then can apply it to the original image and
* its transpose.
* \verbatim
vil2_image_view<vil2_byte> src_image;
vil2_load(src_image,"image_file.jpg");
vil2_image_view<vil2_byte> tmp_image1,tmp_image2;
vil2_filter_rows(tmp_image1,src_image);  // Apply filter to rows of src_image
vil2_filter_rows(tmp_image2,tmp_image1.tranpose());  // Apply filter to cols of tmp_image1
vil2_image_view<vil2_byte> filtered_image = vil2_transpose(tmp_image2);
// Note that vil2_filter_rows(vil2_transpose(filtered_image),vil2_transpose(tmp_image1))
// would only work correctly if filtered_image was already the correct size.
// If it isn't, then the view created by vil2_transpose(filtered_image) would be resized,
// and disconnected from filtered_image itself, which would remain unchanged.
\endverbatim
*
* View manipulations include:
* - vil2_transpose : Return transposed view
* - vil2_reflect_x : View which reflects along x (ie x -> (nx-1)-x) (left/right)
* - vil2_reflect_y : View which reflects along y (ie y -> (ny-1)-y) (up/down)
* - vil2_view_as_planes : View rgb<T> data as planes of T
* - vil2_view_as_rgb : View plane data as rgb<T> pixels
*
* \subsection view_ops Operations on Views
* Useful simple operations on views include
* - vil2_print_all(os,view) : Prints out view in a grid
* - vil2_fill(view,value)   : Fills view with value
* - vil2_fill_row(view,y,value) : Fills row y with value
* - vil2_fill_col(view,x,value) : Fills col x with value
* - vil2_value_range(minv,maxv,view) : Gets range of values in view
*
* \section image_src Image sources
* The vil2_image_data class is an abstract base class for image data, views of which can be
* obtained (or changed) with the get_view()/set_view() functions.
* The two main derived classes are
* - vil2_filetype_image: Representing an image in a file
* - vil2_memory_image: Representing an image in memory (essentially a wrapper around a view)
*
* Most instances of vil2_image_data objecst will be through smart pointers. So expect to see
* lots of references to vil2_image_data_sptr types.
*
* \section algo Algorithms and Image Process
* Some simple algorithms for manipulation images are included in the algo sub-directory.
* Examples include
* - vil2_algo_sobel_3x3 - to generate X/Y gradient images using 3x3 Sobel operators
*
* \section reg_im Registered images
* These meet two needs, a common base class for 2D and 3D images, and a means of
* associating a world to image transform with an image.
*
* \section Examples examples
* There are plenty of working examples in the examples subdirectory - these can be
* treated as a mini-tutorial
*
* \subsection cav_user CAVEAT User
* vil2 is a proposal. It may replace vil in part.
*/
