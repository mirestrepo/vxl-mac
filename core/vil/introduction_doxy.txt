// The following text is included in the main documentation page by doxygen
/*! \mainpage vil2 : New core image library (in development)
* A set of classes to represent and manipulate images
*
* NOTE: This library will in time replace vil as the core image library for vxl
*
* Broadly there are two sorts of image one is interested in - images in memory
* (all parts of which can be accessed directly) and external images (eg in files)
* which can only be accessed indirectly.  In most cases images in files are loaded
* into memory in one go, where they can then be manipulated.  However, for some
* very large images this is not possible or desirable.  In this case it is useful
* to be able to load in a sub-section of the image, manipulate it, and possible
* write it out again.  vil2 supports both memory images and external images.
*
* The core class is vil2_image_view<T> which gives a view of an image in memory.
* The only way to get at the pixel data in an image is through a vil2_image_view<T>.
*
* Large images (in files) can be accessed through the vil2_image_resource class,
* but one can only get at the data by asking for a view of it, which loads the
* requested section into memory and creates a suitable vil2_image_view<T>.
*
* The vil2_image_view<T> represents a view of a multi-plane image of given type.
* A pointer is stored to the top-left pixel in the first plane of the image
* (top_left_ptr()) and integers indicating how to get to neighbours in
* the i (istep()), j (jstep()) and plane (planestep()) directions.
*
* The advantages of this approach are
* - It is actually faster than pointer indirection on most architectures
* - It allows one to access non-contiguous data as if it were a single plane
* - One can use it to wrap up other image classes transparently.
* - It is simple to extend to 3D images, and avoids huge arrays of pointers
*
*
* Note that the same colour image can either be viewed as a one plane image
* with RGB pixels (using vil2_image_view<vil_rgb<vxl_byte> >) or as a 3 plane
* byte image (using vil2_image_view<vxl_byte> with nplanes() == 3).
* \verbatim
vil2_image_view<vil_rgb<vxl_byte> > rgb_image;
rgb_image = vil2_load("my_image.jpg");

// Create a 3 plane view of rgb
vil2_image_view<vxl_byte > three_plane_image =  rgb_image;
// or explicitly
three_plane_image =  vil2_view_as_planes(rgb_image);
// or with less typing
three_plane_image = vil2_load("my_image.jpg");

// Now create rgb view of 3 plane image (note: will set view to empty if not possible)
vil2_image_view<vil_rgb<vxl_byte> > rgb_image2 = three_plane_image;
// or explicitly
rgb_image2 = vil2_view_as_rgb(three_plane_image);

// If you want a greyscale image no matter whether the underlying image is rgb or grey
vil2_image_view<vxl_byte> image2 = vil2_convert_to_grey_using_average<vxl_byte>("my_image.jpg",vxl_byte());

\endverbatim
*
* There are some conversions that will try a fast view conversion only.
* - vil2_view_as_planes(view): Create a multi-plane view from a multi-component view.
* - vil2_view_as_rgb(view): Create an rgb pixel view from a multi-plane view.
*
* There are some conversions that will process each pixel to do a conversion.
* - vil2_convert_to_grey_using_average(view, new_pixel_type): Create a greyscale view from any image.
* - vil2_convert_cast(source, dest): Convert, for example, a byte image to float image
*
* \subsection copying Copying
* Since the vil2_image_view<T> is a `view' of the actual image data, copying one
* only copies the `view', not the image data itself - you get two views looking at
* the same chunk of memory.  Some cunning smart pointer stuff is used to ensure
* that the actual data remains as long as a valid view is looking at
* it.  (Note that this may not always be the case, since the view can be of
* a chunk of memory that the view does not have direct control of, such as a video
* buffer). This view copying will work between different types of view
* if it is possible to reconfigure the view very cheaply.
* If you wish to copy the image data itself, then use the vil2_copy_deep(src_im)
* function. This copies the raw data into a newly created space, and returns
* a new view of it.  Alternatively, use the method dest_im.deep_copy(src_im),
* or the function vil2_copy_reformat(src_im, dest_im).
*
*
* Example of loading, copying then processing:
* \verbatim
vil2_image_view<vxl_byte> image;
image = vil2_load("test_image.jpg");
vil2_image_view<vxl_byte> image2 = vil2_copy_deep(image);
my_invert_image(image2);
vil2_save(image2,"output_image.jpg");
\endverbatim
*
* Example of creating an image in memory
* \verbatim
unsigned ni=256;
unsigned nj=256;
unsigned nplanes=3;
vil2_image_view<vxl_byte> image(ni,nj,nplanes);
for (unsigned p=0;p<nplanes;++p)
  for (unsigned j=0;j<nj;++j)
    for (unsigned i=0;i<ni;++i)
      image(i,j,p) = vxl_byte(i+j+p);
\endverbatim
*
* Example of creating an image in memory, using pointer arithmetic
* \verbatim
  unsigned ni=256;
  unsigned nj=256;
  unsigned nplanes=3;
  vil2_image_view<vxl_byte> image(ni,nj,nplanes);
  vxl_byte* plane = image.top_left_ptr();
  for (unsigned p=0;p<nplanes;++p,plane += image.planestep())
  {
    vxl_byte* row = plane;
    for (unsigned j=0;j<nj;++j,row += image.jstep())
    {
      vxl_byte* pixel = row;
      for (unsigned i=0;i<ni;++i,pixel+=image.istep())
        *pixel = vxl_byte(i+10*j+100*p);
    }
  }
\endverbatim
*
* \subsection resize Resizing
* When one resizes a vil2_image_view<T> the view disconnects from the data
* (which may then be deleted if no other views are connected), allocates a new
* chunk of memory for the new image and sets the view to look at it.
*
* Note that if the resize does not change the image size, then nothing is done
* and the view remains unchanged.
*
* \subsection view_manipulation Manipulating Views
* There are a variety of ways one can view the same data, allowing one to appear
* to change the data simply by changing ones view of it.
*
* For instance one can obtain a transposed view of an image simply by swapping
* ni-nj and istep-jstep.  This is particularly useful when implementing
* decomposable filters, as one need only write it for one direction, then can
* apply it to the original image and its transpose.
* \verbatim
vil2_image_view<vxl_byte> ;
src_image = vil2_load("image_file.jpg");
vil2_image_view<vxl_byte> tmp_image1,tmp_image2;
vil2_exp_filter_1d(tmp_image1,src_image,k,double());  // Apply filter to rows of src_image
vil2_exp_filter_1d(tmp_image2,tmp_image1.tranpose(),k,double());  // Apply filter to cols of tmp_image1
vil2_image_view<vxl_byte> filtered_image = vil2_transpose(tmp_image2);
// Note that
// vil2_exp_filter_1d(vil2_transpose(filtered_image),vil2_transpose(tmp_image1),k,double())
// would only work correctly if filtered_image was already the correct size.
// If it isn't, then the view created by vil2_transpose(filtered_image) would
// be resized, and disconnected from filtered_image itself, which would remain
// unchanged.
\endverbatim
*
* View manipulations include:
* - vil2_transpose     : Return transposed view
* - vil2_flip_lr       : View which reflects along i (ie i -> ni-1-i left/right)
* - vil2_flip_ud       : View which reflects along j (ie j -> nj-1-j up/down)
* - vil2_view_as_planes: View rgb<T> data as planes of T
* - vil2_view_as_rgb   : View plane data as rgb<T> pixels
* - vil2_crop          : View a window into an image
* - vil2_decimate      : View a trivially subsampled image
* - vil2_plane         : View a single plane of an image
*
* \subsection view_ops Operations on Views
* Useful simple operations on views include
* - vil2_print_all(os,view)     : Prints out view in a grid
* - vil2_fill(view,value)       : Fills view with value
* - vil2_fill_row(view,j,value) : Fills row j with value
* - vil2_fill_col(view,i,value) : Fills col i with value
* - vil2_clamp                  : Clamp image pixels to given range
*
* \section image_src Image resources
* The vil2_image_resource class is an abstract base class for image data, views
* of which can be obtained (or changed) with the get_view()/put_view() functions. You
* cannot directly construct one of these vil2_image_resource classes. Instead you use a
* helper function, which will return a smart pointer - expect to see lots of vil2_image_resource_sptr
* objects.
* The types of derived classes, and means of creating them are
* - Representing an image in a file: e.g. vil2_pnm_image, vil2_jpeg_image. These are
*   created using vil2_load_image_data(), and vil2_new_image_resource()
* - vil2_memory_image: Representing an image in memory (essentially a wrapper around a view.)
*   This is created using vil2_new_image_resource().
* - Representing a filtered version of an image in a file (without loading in memory): e.g.
*   vil2_crop_image_resource adn vil2_decimate_image_resource. These are created using the 
*   equivalent functions: vil2_crop(), vil2_decimate(), etc.
* - Representing the outcome of an image processing algorithm (see next section)
*   e.g. vil2_convolve_1d_resource. These are creates using the equivalent functions
*   vil2_convolve_1d().
*
* vil2_image_resource objects in most cases only deal with scalar-type pixels.
* Of course once you get a view of real image data in memory, you can easily
* convert a multi-planar view into a multi-component view.
*
* \section Legacy interfaces
*
* There are two reasons to still use vil1 (currently vxl/vil)
* - vil1  has more image processing functions and image loaders than vil2 at
* the moment.
* - You may have lots of code that uses vil1, and haven't yet converted to vil2.
*
* There are several functions to convert between the various types of vil1 and vil2 images.
* - vil2_vil1_to_image_resource(vil_image): creates a vil2_image_resource.
* - vil2_vil1_to_image_view(vil_memory_image_of<T>): creates a vil2_image_view<T>.
* - vil2_vil1_from_image_view(vil2_image_view<T>): creates a vil_memory_image_of<T>.
*
* \section algo Algorithms and Image Processing
* Some simple algorithms for manipulating images are included in the algo sub-directory.
* Note that the argument order is typically of the form vil2_f(src_im,dest_im,params).
* Examples include
* - vil2_convolve_1d   - Convolve with 1D filter - all manner of edge effects catered for
* - vil2_convolve_2d   - Convolve with 2D filter (no edge effects catered for yet!)
* - vil2_exp_filter_i - Apply exponential filter along i axis (fast recursive method)
* - vil2_exp_filter_j - Apply exponential filter along j axis (fast recursive method)
* - vil2_exp_grad_filter_i - Apply exponential gradient filter along i axis (fast recursive method)
* - vil2_exp_grad_filter_j - Apply exponential gradient filter along j axis (fast recursive method)
* - vil2_sobel_3x3     - to generate X/Y gradient images using 3x3 Sobel operators
* - vil2_gauss_reduce  - smooth and sub-sample to produce half sized image
* - vil2_median        - Compute median over area described by vil2_structuring_element
* See also the vipl library for a more generic image processing interface and
* more image processing algorithms.
*
* \subsection maths Mathematics on images
* Functions to evaluate image properties:
* - vil2_math_value_range       - Get range of values in view
* - vil2_math_sum(sum,im,p)     - Sum of elements in plane of view
* - vil2_math_mean              - Mean of elements
* - vil2_math_mean_and_variance - Mean and variance over view
*
* Functions to modify images:
* - vil2_math_scale_values(im,s)                    : im(x,y,p) = s*im(x,y,p)
* - vil2_math_scale_and_offset_values(im,s,o)       : im(x,y,p) = s*im(x,y,p)+o
* - vil2_math_image_sum(imA,imB,im_sum)             : im_sum = imA+imB
* - vil2_math_image_difference(imA,imB,im_diff)     : im_diff = imA-imB
* - vil2_math_image_abs_difference(imA,imB,im_diff) : im_diff = |imA-imB|
* - vil2_math_add_image_fraction(imA,fa,imB,fb)     : imA = fa*imA + fb*imB  (Useful for moving averages!)
*
* Morphological functions  (using vil2_structuring_element)
* - vil2_binary_erode
* - vil2_binary_dilate
* - vil2_binary_opening
* - vil2_binary_closing
* - vil2_greyscale_erode
* - vil2_greyscale_dilate
* - vil2_greyscale_opening
* - vil2_greyscale_closing
* - vil2_median
*
* Other related maths functions
* - vil2_math_integral_image(imA,im_sum)               : Images integrating values
* - vil2_math_integral_sqr_image(imA,im_sum,im_sum_sq) : Images integrating values and square of values
*
* \subsection interp Interpolating images
* Bilinear interpolation (of single planes of scalar types) can be obtained using
* - vil2_bilin_interp      : Intepolate, using assert to check if in valid region
* - vil2_bilin_interp_raw  : Interpolate, assuming point in valid region (seg fault otherwise)
* - vil2_bilin_interp_safe : Interpolate, returning zero if outside image
* - vil2_bilin_interp_safe_extend : Interpolate, returning nearest edge value if outside
*
* Other methods of sampling include:
* - vil2_sample_profile_bilin : Sample values along a line (using bilin. interpolation)
* - vil2_sample_grid_bilin : Sample values over a grid (using bilin. interpolation)
*
* \subsection conventions Parameter Conventions
* For your ease of use, all vil2 functions and methods adhere to the following
* parameter conventions:
* - Index types         - All pixel index and image size types are unsigned.
* - Specifying a pixel  - func(i,j) assumes plane 0 or func(i,j,p)
* - Specifying a window - func(i0,ni,j0,nj) window includes all planes.
*
* \section Examples examples
* There are plenty of working examples in the examples subdirectory - these can
* be treated as a mini-tutorial.
*/
